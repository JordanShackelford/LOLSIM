<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Caitlyn AI Free For All with Abilities and Headshot</title>
<style>
  body { margin: 0; overflow: hidden; background: #1e1e1e; color: white; font-family: sans-serif; }
  canvas { display: block; margin: 0 auto 0 auto; background: #222; position: relative; top: 20px; }
  #ui {
    position: fixed;
    top: 20px; left: 20px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 8px;
    max-width: 300px;
    z-index: 10;
  }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<div id="ui">
  <label>Mutation Rate: <input type="range" id="mutationRate" min="0" max="0.5" step="0.01" value="0.1" /></label><br />
  <label>Attack Bias: <input type="range" id="attackBias" min="-1" max="1" step="0.05" value="0" /></label><br />
  <label>Speed: <input type="range" id="speed" min="1" max="20" step="0.1" value="1.0" /></label><br />
  <button id="speed2000Btn" style="margin-left:8px;">2000x</button>
  <button id="showADBtn" style="margin-left:8px;">Show AD</button>
  <button id="showFitnessBtn" style="margin-left:8px;">Show Fitness</button>
  <button id="showZedBtn" style="margin-left:8px;">Show Zed: OFF</button>
  <div id="stats">Generation: 1<br>Avg Attacks: 0<br>Avg Qs: 0<br></div>
</div>
<div id="teamGraphUI"></div>
<canvas id="gameCanvas" width="1200" height="800"></canvas>
<script>
const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 800;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Wild Rift map: 13,000 units wide = 1200px
const GAME_UNIT_TO_PX = CANVAS_WIDTH / 13000; // â‰ˆ 0.0923 px per unit

// Caitlyn stats (in game units, then converted to px)
const CAITLYN_RADIUS = 20 * GAME_UNIT_TO_PX; // 20 units
const BASE_ATTACK_RANGE = 650 * GAME_UNIT_TO_PX; // 650 units
const HEADSHOT_RANGE = 1300 * GAME_UNIT_TO_PX; // 1300 units
const CAITLYN_MOVE_SPEED = 325 * GAME_UNIT_TO_PX; // 325 units/sec
const CAITLYN_PROJECTILE_SPEED = 2500 * GAME_UNIT_TO_PX; // 2500 units/sec

// Q ability constants (in game units)
const Q_RANGE = 1300 * GAME_UNIT_TO_PX; // 1300 units (true to real game)
const Q_WIDTH = 120 * GAME_UNIT_TO_PX; // 120 units (true to real game)
const Q_WIDTH_EXPANDED = 180 * GAME_UNIT_TO_PX; // 180 units (true to real game)
const Q_SPEED = 2200 * GAME_UNIT_TO_PX; // 2200 units/sec

// Trap constants (in game units)
const TRAP_TRIGGER_RADIUS = 67.5 * GAME_UNIT_TO_PX; // 67.5 units

// Bush radii (in game units)
const bushList = [
  {x: 2000 * GAME_UNIT_TO_PX, y: 2000 * GAME_UNIT_TO_PX, r: 60 * GAME_UNIT_TO_PX},
  {x: 10000 * GAME_UNIT_TO_PX, y: 2000 * GAME_UNIT_TO_PX, r: 60 * GAME_UNIT_TO_PX},
  {x: 6000 * GAME_UNIT_TO_PX, y: 4000 * GAME_UNIT_TO_PX, r: 80 * GAME_UNIT_TO_PX},
  {x: 3000 * GAME_UNIT_TO_PX, y: 7000 * GAME_UNIT_TO_PX, r: 60 * GAME_UNIT_TO_PX},
  {x: 9000 * GAME_UNIT_TO_PX, y: 7000 * GAME_UNIT_TO_PX, r: 60 * GAME_UNIT_TO_PX},
  {x: 6000 * GAME_UNIT_TO_PX, y: 1000 * GAME_UNIT_TO_PX, r: 50 * GAME_UNIT_TO_PX},
  {x: 6000 * GAME_UNIT_TO_PX, y: 7000 * GAME_UNIT_TO_PX, r: 50 * GAME_UNIT_TO_PX}
];

// Turret range (in game units)
// Update Turret class to use this
const TURRET_RANGE = 180 * GAME_UNIT_TO_PX; // 180 units

// Minion stats (in game units)
const MINION_TYPES = {
  melee: {
    baseHp: 200,
    baseAd: 16, // doubled from 8
    attackSpeed: 0.8,
    moveSpeed: 325 * GAME_UNIT_TO_PX,
    range: 240 * GAME_UNIT_TO_PX, // doubled from 120
    gold: 65,
    armor: 0,
    mr: 0,
    xp: 60,
    radius: 24 * GAME_UNIT_TO_PX,
    color: '#bca',
  },
  caster: {
    baseHp: 140,
    baseAd: 12, // doubled from 6
    attackSpeed: 0.7,
    moveSpeed: 325 * GAME_UNIT_TO_PX,
    range: 1000 * GAME_UNIT_TO_PX, // doubled from 500
    gold: 45,
    armor: 0,
    mr: 0,
    xp: 30,
    radius: 20 * GAME_UNIT_TO_PX,
    color: '#8cf',
  },
  cannon: {
    baseHp: 350,
    baseAd: 30, // doubled from 15
    attackSpeed: 0.6,
    moveSpeed: 285 * GAME_UNIT_TO_PX,
    range: 600 * GAME_UNIT_TO_PX, // doubled from 300
    gold: 85,
    armor: 15,
    mr: 15,
    xp: 93,
    radius: 32 * GAME_UNIT_TO_PX,
    color: '#fa4',
    turretDmgReduction: 0.7,
  },
  super: {
    baseHp: 700,
    baseAd: 80, // doubled from 40
    attackSpeed: 0.8,
    moveSpeed: 325 * GAME_UNIT_TO_PX,
    range: 400 * GAME_UNIT_TO_PX, // doubled from 200
    gold: 150,
    armor: 40,
    mr: 40,
    xp: 97,
    radius: 38 * GAME_UNIT_TO_PX,
    color: '#f44',
    turretDmgReduction: 0.5,
  }
};

const CAITLYN_BASE_HP = 580;
const CAITLYN_BASE_AD = 59;  // Set to correct base AD
const CAITLYN_BASE_AS = 0.681;
const CAITLYN_AS_RATIO = 0.625;
const CAITLYN_ARMOR = 0;
const CAITLYN_MR = 0;
const CAITLYN_ATTACK_RANGE_UNITS = 650 * 2; // double original range
const CAITLYN_ATTACK_RANGE = CAITLYN_ATTACK_RANGE_UNITS * GAME_UNIT_TO_PX;

// Headshot constants
const HEADSHOT_STACKS_NEEDED = 5;
const HEADSHOT_STACKS_BRUSH = 4;
const HEADSHOT_BONUS_MULT = 0.6; // 60% bonus AD
const HEADSHOT_RANGE_UNITS = 1300 / 3; // 1/3 original
const HEADSHOT_WINDUP_PCT = 0.17708; // 17.7%

// Q ability constants (scaled to px)
const Q_CAST_TIME = 0.625; // seconds
const Q_RANGE_UNITS = 1300;
const Q_SPEED_UNITS = 2200;
const Q_WIDTH_UNITS = 120;  // Increased from 60
const Q_WIDTH_EXPANDED_UNITS = 180;  // Increased from 90
const Q_DAMAGE_RATIO = 2.05; // 205% total AD (max rank)
const Q_DAMAGE_FALLOFF = 0.5; // 50% to secondary targets
const Q_BASE_DAMAGE = 210; // Base damage at max rank

// Trap constants
const TRAP_CAP = 3;
const TRAP_RECHARGE = 0.1; // seconds per trap
const TRAP_DURATION = 30; // seconds
const TRAP_ARM_TIME = 1.1; // seconds
const TRAP_TRIGGER_RADIUS_UNITS = 67.5;
const TRAP_ROOT_DURATION = 1.5; // seconds
const TRAP_REVEAL_DURATION = 3; // seconds
const TRAP_MARK_DURATION = 2.5; // seconds
const TRAP_HEADSHOT_BONUS = 1.2; // +120% headshot bonus
const TRAP_HEADSHOT_RANGE_MULT = 2; // double range

// Trap class (must be defined before CaitlynAI and any use)
class Trap {
  constructor(owner, x, y) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.placedAt = performance.now() / 1000;
    this.armedAt = this.placedAt + TRAP_ARM_TIME;
    this.expiresAt = this.placedAt + TRAP_DURATION;
    this.armed = false;
    this.triggered = false;
    this.triggeredAt = null;
    this.target = null;
    this.alive = true;
  }
  update(now) {
    if (!this.armed && now >= this.armedAt) this.armed = true;
    if (this.triggered && now - this.triggeredAt > 0.5) this.alive = false; // remove after short delay
    if (now >= this.expiresAt) this.alive = false;
  }
  draw() {
    ctx.save();
    if (trapImgLoaded) {
      ctx.globalAlpha = this.armed ? 0.8 : 0.4;
      const size = 24;
      ctx.drawImage(trapImg, this.x - size / 2, this.y - size / 2, size, size);
      ctx.globalAlpha = 1;
    } else {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
      ctx.fillStyle = this.armed ? (this.triggered ? '#e74c3c' : '#ffeb3b') : '#888';
      ctx.globalAlpha = this.armed ? 0.8 : 0.4;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // Draw thin team color outline
    ctx.beginPath();
    ctx.arc(this.x, this.y, 14, 0, Math.PI * 2);
    ctx.strokeStyle = TEAM_COLORS[this.owner.team];
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.9;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}


// 2. Update inBrush(x, y) to check if a point is inside any bush
function inBrush(x, y) {
  return bushList.some(b => Math.hypot(x - b.x, y - b.y) < b.r);
}
// Helper: which bush index (or -1 if none)
function whichBush(x, y) {
  for (let i = 0; i < bushList.length; ++i) {
    const b = bushList[i];
    if (Math.hypot(x - b.x, y - b.y) < b.r) return i;
  }
  return -1;
}

// Helper: distance to nearest bush
function distToNearestBush(x, y) {
  let minDist = Infinity;
  for (const b of bushList) {
    const d = Math.max(0, Math.hypot(x - b.x, y - b.y) - b.r);
    if (d < minDist) minDist = d;
  }
  return minDist;
}

// Basic Ability drawing helper
class Ability {
  static drawProjectile(x, y, color, type) {
    ctx.beginPath();
    ctx.arc(x, y, type === 'Q' ? 12 : 6, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.globalAlpha = type === 'Q' ? 0.5 : 1;
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// Projectile class
class Projectile {
  constructor(x, y, angle, speed, color, type) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = speed;
    this.color = color;
    this.radius = type === 'Q' ? 12 : 6;
    this.type = type;
    this.alive = true;
  }

  update(delta) {
    this.x += Math.cos(this.angle) * this.speed * delta;
    this.y += Math.sin(this.angle) * this.speed * delta;
    if (this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT) this.alive = false;
  }

  draw() {
    Ability.drawProjectile(this.x, this.y, this.color, this.type);
  }
}

// Basic attack projectile animation class
class BasicProjectile {
  constructor(x0, y0, x1, y1, color, onHit, isHeadshot, targetRef, damage) {
    this.x = x0;
    this.y = y0;
    this.x0 = x0; this.y0 = y0;
    this.x1 = x1; this.y1 = y1;
    this.color = color;
    this.alive = true;
    this.onHit = onHit;
    this.isHeadshot = isHeadshot;
    this.targetRef = targetRef; // pass the target object reference
    this.speed = 600; // px/sec, very slow for visibility
    this.lifetime = 0;
    this.minLifetime = 0.2; // always visible for at least 0.2s
    this.damage = damage !== undefined ? damage : 1; // <-- NEW: store damage
  }
  update(dt) {
    if (!this.alive) return;
    this.lifetime += dt;
    // Move toward target's current position if available
    let tx = this.x1, ty = this.y1;
    if (this.targetRef && this.targetRef.x !== undefined && this.targetRef.y !== undefined) {
      tx = this.targetRef.x;
      ty = this.targetRef.y;
    }
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.hypot(dx, dy);
    const move = Math.min(this.speed * dt, dist);
    if (dist > 0) {
      this.x += (dx / dist) * move;
      this.y += (dy / dist) * move;
    }
    // Hit if within 20px of target, but only allow removal after minLifetime
    if (dist < 20 && this.lifetime > this.minLifetime) {
      this.alive = false;
      if (this.onHit) this.onHit();
    }
  }
  draw() {
    if (!window._projectileDebug) window._projectileDebug = [];
    window._projectileDebug.push({x: this.x, y: this.y});
    // ... existing draw code ...
    ctx.save();
    // Draw a thin, faint trail
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.x0, this.y0);
    ctx.lineTo(this.x, this.y);
    ctx.stroke();
    // Draw a small, simple bullet
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.isHeadshot ? 7 : 5, 0, Math.PI * 2);
    ctx.fillStyle = this.isHeadshot ? '#bbb' : '#888';
    ctx.fill();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = '#222';
    ctx.stroke();
    ctx.restore();
  }
}

// Load Caitlyn sprite
const caitlynImg = new Image();
caitlynImg.src = 'caitlyn.png';
let caitlynImgLoaded = false;
caitlynImg.onload = () => { caitlynImgLoaded = true; };

// TEAMFIGHT CONSTANTS
const TEAM_SIZE = 5;
const NUM_TEAMS = 2;
const NUM_CAITLYNS = TEAM_SIZE * NUM_TEAMS;
const TEAM_COLORS = ['#8e44ad', '#e74c3c'];

// Helper: angle between two points
function angleBetween(x1, y1, x2, y2) {
  return Math.atan2(y2 - y1, x2 - x1);
}

// Simple feedforward neural net (2 hidden layers)
function feedforward(inputs, weights) {
  // 35 input, 24 hidden1, 12 hidden2, 11 output
  const numInputs = 35, H1 = 24, H2 = 12, O = 11;
  let hidden1 = Array(H1).fill(0);
  let hidden2 = Array(H2).fill(0);
  let out = Array(O).fill(0);
  // Input to hidden1
  for (let h = 0; h < H1; ++h) {
    for (let i = 0; i < numInputs; ++i) {
      hidden1[h] += inputs[i] * weights[h * numInputs + i];
    }
    hidden1[h] = Math.tanh(hidden1[h] + weights[H1 * numInputs + h]);
  }
  // Hidden1 to hidden2
  let offset = H1 * numInputs + H1;
  for (let h2 = 0; h2 < H2; ++h2) {
    for (let h1 = 0; h1 < H1; ++h1) {
      hidden2[h2] += hidden1[h1] * weights[offset + h2 * H1 + h1];
    }
    hidden2[h2] = Math.tanh(hidden2[h2] + weights[offset + H2 * H1 + h2]);
  }
  // Hidden2 to output
  offset += H2 * H1 + H2;
  for (let o = 0; o < O; ++o) {
    for (let h2 = 0; h2 < H2; ++h2) {
      out[o] += hidden2[h2] * weights[offset + o * H2 + h2];
    }
    out[o] = Math.tanh(out[o] + weights[offset + O * H2 + o]);
  }
  return out;
}

// Helper function to find the best Caitlyn (highest fitness)
function findBestCaitlyn() {
  let best = null;
  let bestFitness = -Infinity;
  
  for (const c of caitlyns) {
    if (c.fitness > bestFitness) {
      bestFitness = c.fitness;
      best = c;
    }
  }
  
  return best;
}

// CaitlynAI class
class CaitlynAI {
  constructor(x, y, color, team, brain) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.team = team;
    // --- Robust state reset ---
    this.dead = false;
    this.isRecalling = false;
    this.windupTimer = 0;
    this.trapRootTimer = 0;
    this.rChanneling = false;
    this.trapped = false;
    this.qWindup = 0;
    this.qActive = false;
    this.recallTimer = 0;
    this.rChannelTime = 0;
    this.rTarget = null;
    this.pendingAttack = null;
    // --- End robust state reset ---
    this.hp = CAITLYN_BASE_HP;
    this.dead = false;
    this.attackTimer = 0;
    this.brain = brain || CaitlynAI.randomBrain();
    this.attackSpeed = CAITLYN_BASE_AS;
    this.attackDelay = 1 / this.attackSpeed;
    this.attackWindup = HEADSHOT_WINDUP_PCT * this.attackDelay;
    this.windupTimer = 0;
    this.pendingAttack = null;
    this.damageDealt = 0;
    this.moveSpeed = CAITLYN_MOVE_SPEED;
    this.attackRange = CAITLYN_ATTACK_RANGE;
    this.projectileSpeed = CAITLYN_PROJECTILE_SPEED;
    this.armor = CAITLYN_ARMOR;
    this.mr = CAITLYN_MR;
    this.qWindup = 0; // Q cast windup timer
    this.qActive = false; // Q is being cast
    this.qProjectile = null; // Q projectile reference
    // Trap-related properties
    this.traps = [];
    this.trapCooldown = 0;
    this.trapCharges = TRAP_CAP;
    this.lastTrapPlaced = 0;
    this.trapRechargeTimer = 0;
    this.trapTargets = new Set();
    this.trapMark = null;
    this.trapped = false;
    this.trapRootTimer = 0;
    this.trapRevealTimer = 0;
    this.trapMarkTimer = 0;
    this.trapMarkedBy = null;
    this.gold = 0;
    this.minDistToEnemyNexus = Infinity;
    this.lastMoveCommandTime = 0;
    this.cachedMove = { x: 0, y: 0 };
    this.respawnTimer = 0;
    this.dead = false;
    this.items = [];
    this.isRecalling = false;
    this.recallTimer = 0;
    this.canBuy = false;
    this.fitness = 0; // Add fitness property
    this.kills = 0;
    this.assists = 0;
    this.deaths = 0;
    this.minionLastHits = 0;
    this.turretsDestroyed = 0;
    this.goldSpent = 0;
    this.idleTime = 0;
    this.bushTime = 0;
    this.lastActiveTime = performance.now() / 1000;
    this.lastPosition = { x: x, y: y };
    this.nexusDamage = 0;
    this.turretDamage = 0;
    this.unspentGold = 0;
    this.survived = false;
    this.tookDamage = false;
    // In CaitlynAI constructor, add E ability state
    this.eCooldown = 0;
    this.eActive = false;
    this.eSlowTimer = 0;
    this.eSlowedBy = null;
    // In CaitlynAI constructor, add:
    this.rCooldown = 0;
    this.rChanneling = false;
    this.rChannelTime = 0;
    this.rTarget = null;
    // In CaitlynAI constructor, add speech bubble state
    this.lastThought = '';
    this.thoughtTimer = 0;
    // --- Temporal input stacking for neural net ---
    // Set number of frames to stack
    this.TEMPORAL_FRAMES = 8;
    // In CaitlynAI constructor, add XP, level, and mana properties
    this.xp = 0;
    this.level = 1;
    this.mana = 313; // Caitlyn base mana
    this.maxMana = 313;
    this.manaRegen = 7.4; // per 5s, so 1.48/s
    this.xpToNext = [0, 280, 660, 1140, 1720, 2260, 2840, 3460, 4120, 4820, 5560, 6340, 7160, 8020, 8920, 9860];
    // In CaitlynAI constructor, add:
    this.basicAttackCount = 0;
    // In CaitlynAI constructor, add:
    this.baseAD = 59;
    this.adGrowth = 3.4;
  }
  static INPUTS = 35; // 18 original + 9 for traps + eCooldown + nearestEnemyDist + 6 for minion info (3 friendly, 3 enemy)
  static HIDDEN1 = 24;
  static HIDDEN2 = 12;
  static OUTPUTS = 9; // moveX, moveY, attack, buy, recall, trap, target, useE, qAngle
  static WEIGHTS_LEN =
    CaitlynAI.INPUTS * CaitlynAI.HIDDEN1 + CaitlynAI.HIDDEN1 +
    CaitlynAI.HIDDEN1 * CaitlynAI.HIDDEN2 + CaitlynAI.HIDDEN2 +
    CaitlynAI.HIDDEN2 * CaitlynAI.OUTPUTS + CaitlynAI.OUTPUTS;
  static randomBrain() {
    return Array.from({ length: CaitlynAI.WEIGHTS_LEN }, () => Math.random() * 2 - 1);
  }
  static mutate(brain, rate) {
    let out = brain.slice();
    while (out.length < CaitlynAI.WEIGHTS_LEN) out.push(Math.random() * 2 - 1);
    while (out.length > CaitlynAI.WEIGHTS_LEN) out.pop();
    return out.map(w => w + (Math.random() * 2 - 1) * rate);
  }
  // In CaitlynAI decide, allow targeting of minions, turrets, or players
  // Add minions and turrets as arguments to decide and update
  decide(allCaitlyns, minions, turrets) {
    // Inputs: for each enemy/ally: dx, dy, hp (normalized), self: cooldowns, headshot, inBrush
    let inputs = [];
    let me = this;
    // Bush vision: filter out enemies in bush if Caitlyn is not in same bush
    const myBush = whichBush(this.x, this.y);
    let enemies = allCaitlyns.filter(c => c.team !== this.team && c.hp > 0 && (myBush === -1 || whichBush(c.x, c.y) === myBush || whichBush(c.x, c.y) === -1));
    let allies = allCaitlyns.filter(c => c.team === this.team && c !== this && c.hp > 0);
    // For each enemy: dx, dy, hp (max TEAM_SIZE)
    for (let i = 0; i < TEAM_SIZE; ++i) {
      let e = enemies[i] || { x: 0, y: 0, hp: 0 };
      inputs.push((e.x - me.x) / CANVAS_WIDTH, (e.y - me.y) / CANVAS_HEIGHT, e.hp / 600);
    }
    // For each ally: dx, dy, hp (max TEAM_SIZE-1)
    for (let i = 0; i < TEAM_SIZE - 1; ++i) {
      let a = allies[i] || { x: 0, y: 0, hp: 0 };
      inputs.push((a.x - me.x) / CANVAS_WIDTH, (a.y - me.y) / CANVAS_HEIGHT, a.hp / 600);
    }
    // Self: cooldowns, headshot, inBrush (4 values)
    inputs.push(this.attackTimer / 2, this.qTimer / 10, this.headshotReady ? 1 : 0, inBrush(this.x, this.y) ? 1 : 0);
    // Add distance to nearest bush (normalized)
    inputs.push(distToNearestBush(this.x, this.y) / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT));
    // Add distance to nearest enemy turret's range (negative if inside, positive if outside, normalized)
    let minTurretDist = 1e9;
    for (const t of turrets) {
      if (t.team !== this.team) {
        const d = Math.hypot(this.x - t.x, this.y - t.y) - t.range;
        if (Math.abs(d) < Math.abs(minTurretDist)) minTurretDist = d;
      }
    }
    // Normalize by dividing by max map dimension
    inputs.push(Math.max(-1, Math.min(1, minTurretDist / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT))));
    // Truncate if too long
    if (inputs.length > 18) inputs = inputs.slice(0, 18);
    // Pad to exactly 18 inputs
    while (inputs.length < 18) inputs.push(0);
    if (inputs.length !== 18) {
      console.error('Neural net input length error:', inputs.length, inputs);
    }
    // After existing 18 inputs:
    // Add 3 nearest traps (dx, dy, armed)
    let allTraps = [];
    caitlyns.forEach(c => allTraps.push(...c.traps));
    allTraps = allTraps.filter(trap => trap.alive);
    allTraps.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    for (let i = 0; i < 3; ++i) {
      const trap = allTraps[i];
      if (trap) {
        inputs.push((trap.x - me.x) / CANVAS_WIDTH);
        inputs.push((trap.y - me.y) / CANVAS_HEIGHT);
        inputs.push(trap.armed ? 1 : 0);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    // Add E cooldown
    inputs.push(this.eCooldown / 16); // Normalize by max cooldown
    // Add distance to nearest enemy
    let nearestEnemyDist = 1e9;
    for (const enemy of enemies) {
      const dist = Math.hypot(enemy.x - me.x, enemy.y - me.y);
      if (dist < nearestEnemyDist) nearestEnemyDist = dist;
    }
    inputs.push(Math.min(1, nearestEnemyDist / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT)));
    // Add minion information: 3 nearest friendly minions and 3 nearest enemy minions
    let friendlyMinions = minions.filter(m => m.team === this.team && m.alive);
    let enemyMinions = minions.filter(m => m.team !== this.team && m.alive);
    
    // Sort by distance to Caitlyn
    friendlyMinions.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    enemyMinions.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    
    // Add 3 nearest friendly minions (dx, dy, hp)
    for (let i = 0; i < 3; ++i) {
      const minion = friendlyMinions[i];
      if (minion) {
        inputs.push((minion.x - me.x) / CANVAS_WIDTH);
        inputs.push((minion.y - me.y) / CANVAS_HEIGHT);
        inputs.push(minion.hp / minion.baseHp); // Normalized HP
      } else {
        inputs.push(0, 0, 0);
      }
    }
    
    // Add 3 nearest enemy minions (dx, dy, hp)
    for (let i = 0; i < 3; ++i) {
      const minion = enemyMinions[i];
      if (minion) {
        inputs.push((minion.x - me.x) / CANVAS_WIDTH);
        inputs.push((minion.y - me.y) / CANVAS_HEIGHT);
        inputs.push(minion.hp / minion.baseHp); // Normalized HP
      } else {
        inputs.push(0, 0, 0);
      }
    }
    // --- Temporal input stacking for neural net ---
    // Set number of frames to stack
    const TEMPORAL_FRAMES = 8;

    // Update getRequiredBrainLength to use temporal stacking
    function getRequiredBrainLength() {
      const perFrameInputs = 37; // was 35
      const frames = TEMPORAL_FRAMES;
      const numInputs = perFrameInputs * frames, H1 = 128, H2 = 128, H3 = 64, O = 11;
      return numInputs * H1 + H1 + H1 * H2 + H2 + H2 * H3 + H3 + H3 * O + O;
    }
    // Update migrateBrain for compatibility
    function migrateBrain(brain) {
      const len = getRequiredBrainLength();
      let out = Array.isArray(brain) ? brain.slice() : [];
      while (out.length < len) out.push(Math.random() * 2 - 1);
      while (out.length > len) out.pop();
      return out;
    }
    // In CaitlynAI and Zed input logic (decide/update):
    if (!this.inputHistory) this.inputHistory = [];
    let frameInputs = [/* ... per-frame features ... */]; // build as before
    this.inputHistory.push(frameInputs);
    if (this.inputHistory.length > TEMPORAL_FRAMES) this.inputHistory.shift();
    let stackedInputs = this.inputHistory.flat();
    while (stackedInputs.length < 37 * TEMPORAL_FRAMES) stackedInputs.push(0);
    // Feed stackedInputs to neural net
    let out = feedforward(stackedInputs, this.brain);
    if (out.some(x => isNaN(x))) {
      console.error('Neural net output NaN:', out, inputs, this.brain);
    }
    // Outputs: moveX, moveY, attackProb, useQProb, buyProb, recallProb, trapProb, useE, qAngle
    let targetType = Math.max(0, Math.min(2, Math.floor((out[4] + 1) * 1.5)));
    let targetIdx = 0;
    let target = null;
    if (targetType === 0) {
      // Minion
      let enemyMinions = minions.filter(m => m.team !== this.team && m.alive);
      if (enemyMinions.length > 0) {
        // Closest minion
        enemyMinions.sort((a, b) => Math.hypot(a.x - this.x, a.y - this.y) - Math.hypot(b.x - this.x, b.y - this.y));
        target = enemyMinions[0];
      }
    } else if (targetType === 1) {
      // Turret
      let enemyTurrets = turrets.filter(t => t.team !== this.team);
      if (enemyTurrets.length > 0) {
        // Closest enemy turret
        enemyTurrets.sort((a, b) => Math.hypot(a.x - this.x, a.y - this.y) - Math.hypot(b.x - this.x, b.y - this.y));
        target = enemyTurrets[0];
      }
    } else {
      // Player
      if (enemies.length > 0) {
        // Closest enemy Caitlyn
        enemies.sort((a, b) => Math.hypot(a.x - this.x, a.y - this.y) - Math.hypot(b.x - this.x, b.y - this.y));
        target = enemies[0];
      }
    }
    const [moveX, moveY, attack, useQ, buy, recall, trap, useE, useR, qAngle, rTarget] = out;
    this.moveX = moveX;
    this.moveY = moveY;
    this.attackIntent = attack;
    this.buyIntent = buy;
    this.recallIntent = recall;
    this.trapIntent = trap;
    this.useEIntent = useE;
    this.useRIntent = useR;
    this.qAngle = qAngle; // Store Q angle for aiming
    this.rTarget = rTarget; // Store rTarget for targeting
    
    // Debug logging for first few frames to understand Q casting behavior
    // (Removed forced minion targeting for first 300 generations)
    // End removed block
    
    return { moveX, moveY, target, attack: attack > -0.5, useQ: useQ > 0.5, useR: useR > 0.5, rTarget, qAngle };
  }

  update(others, delta, projectiles, minions, turrets) {
    const now = performance.now() / 1000;
    if (this.dead) {
      if (!allowRespawn) return;
      this.respawnTimer -= delta;
      if (this.respawnTimer <= 0) {
        // Respawn at own Nexus
        this.x = NEXUS_POS[this.team].x;
        this.y = NEXUS_POS[this.team].y;
        this.hp = CAITLYN_BASE_HP + this.getBonusHP();
        this.dead = false;
        this.lastHitBy = null; // Reset lastHitBy on respawn
        // Copy the best Caitlyn's brain with small mutation
        const bestCaitlyn = findBestCaitlyn();
        if (bestCaitlyn && bestCaitlyn !== this) {
          // Copy best brain with small mutation for diversity
          this.brain = CaitlynAI.mutate(bestCaitlyn.brain, 0.05); // 5% mutation rate
          console.log(`Caitlyn (team ${this.team}) copied brain from best performer (fitness: ${bestCaitlyn.fitness.toFixed(1)})`);
          saveBrain(bestCaitlyn.brain); // Save best brain to localStorage on respawn
        } else {
          saveBrain(this.brain); // Save own brain if best
        }
      }
      return;
    }
    if (this.hp <= 0) {
      // Award 300 gold to the last enemy Caitlyn who hit this one
      if (this.lastHitBy && this.lastHitBy.team !== this.team) {
        this.lastHitBy.gold += 300;
      }
      // On death, set respawn timer to ceil(game time in seconds)
      const gameTime = (typeof generationStartTime === 'number' && lastTime) ? ((lastTime - generationStartTime) / 1000) : now;
      this.respawnTimer = Math.ceil(gameTime);
      this.dead = true;
      return;
    }
    // Recall logic
    if (this.isRecalling) {
      this.recallTimer -= delta;
      // If took damage, cancel recall
      if (this.tookDamage) {
        this.isRecalling = false;
        this.recallTimer = 0;
        this.tookDamage = false;
        console.log(`Caitlyn (team ${this.team}) recall INTERRUPTED by damage at (${Math.round(this.x)},${Math.round(this.y)})`);
      } else if (this.recallTimer <= 0) {
        // Teleport to base
        this.x = NEXUS_POS[this.team].x;
        this.y = NEXUS_POS[this.team].y;
        this.isRecalling = false;
        this.canBuy = true;
        console.log(`Caitlyn (team ${this.team}) recall COMPLETED, teleported to base with gold: ${this.gold}`);
      }
      return;
    }
    // If at base and can buy, buy items if enough gold
    if (this.canBuy && Math.hypot(this.x - NEXUS_POS[this.team].x, this.y - NEXUS_POS[this.team].y) < NEXUS_RADIUS + 10) {
      for (const item of ITEM_SHOP) {
        while (this.gold >= item.cost) {
          this.gold -= item.cost;
          this.items.push(item);
          this.goldSpent += item.cost;
          // Allow buying multiple Long Swords per base visit
        }
      }
      this.canBuy = false;
    }
    // Trap recharge and placement logic (always runs)
    if (this.trapCharges < TRAP_CAP) {
      this.trapRechargeTimer += delta;
      if (this.trapRechargeTimer >= TRAP_RECHARGE) {
        this.trapCharges++;
        this.trapRechargeTimer = 0;
      }
    }
    // Remove expired traps
    this.traps = this.traps.filter(trap => trap.alive && (performance.now() / 1000) < trap.expiresAt);
    // Place trap randomly if available and not too many active
    if (this.trapCharges > 0 && this.traps.length < TRAP_CAP && Math.random() < 0.01) {
      // Only allow trap placement within 40 units of Caitlyn's current position
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 40; // max 40 units
      const tx = Math.max(20, Math.min(CANVAS_WIDTH - 20, this.x + Math.cos(angle) * radius));
      const ty = Math.max(20, Math.min(CANVAS_HEIGHT - 20, this.y + Math.sin(angle) * radius));
      this.traps.push(new Trap(this, tx, ty));
      this.trapCharges--;
      this.lastTrapPlaced = performance.now() / 1000;
    }
    // Trap logic: arming, triggering
    for (const trap of this.traps) {
      trap.update(now);
      if (trap.armed && !trap.triggered) {
        for (const enemy of others) {
          // Patch: allow Zed to be trapped too
          if (enemy.team !== this.team && enemy.hp > 0 && !enemy.trapped /* && (enemy.isZed || enemy.constructor.name === 'CaitlynAI') */) {
            const dist = Math.hypot(enemy.x - trap.x, enemy.y - trap.y);
            if (dist < TRAP_TRIGGER_RADIUS) {
              trap.triggered = true;
              trap.triggeredAt = now;
              trap.target = enemy;
              enemy.trapped = true;
              enemy.trapRootTimer = TRAP_ROOT_DURATION;
              enemy.trapRevealTimer = TRAP_REVEAL_DURATION;
              enemy.trapMarkTimer = TRAP_MARK_DURATION;
              enemy.trapMarkedBy = this;
              break;
            }
          }
        }
      }
    }
    // Trap mark logic (for empowered headshot)
    if (this.trapMark && (performance.now() / 1000) > this.trapMark.expiresAt) {
      this.trapMark = null;
    }
    // Trap root and reveal
    if (this.trapped) {
      this.trapRootTimer -= delta;
      this.trapRevealTimer -= delta;
      this.trapMarkTimer -= delta;
      if (this.trapRootTimer > 0) {
        // Immobilized: skip movement/attack
        return;
      }
      if (this.trapRootTimer <= 0 && this.trapped) {
        this.trapped = false;
      }
      if (this.trapMarkTimer <= 0) {
        this.trapMarkedBy = null;
      }
    }
    // Headshot stack logic: always define at the top
    let stacksNeeded = inBrush(this.x, this.y) ? HEADSHOT_STACKS_BRUSH : HEADSHOT_STACKS_NEEDED;
    this.attackTimer -= delta;
    this.qTimer -= delta;

    const { moveX, moveY, target, attack, useQ, buy, recall, trap, useE, useR, qAngle, rTarget } = this.decide(others, minions, turrets);
    let doAttack = attack;
    // Fallback: if not attacking but in range and cooldown is ready, force attack
    if ((!doAttack || !attack) && target && this.attackTimer <= 0) {
      const dist = Math.hypot(target.x - this.x, target.y - this.y);
      let attackRange = this.attackRange;
      if (target.trapped || target.netted) attackRange = HEADSHOT_RANGE;
      if (dist <= attackRange) doAttack = true;
    }

    // Q windup/cast logic
    if (this.qWindup > 0) {
      // --- Q cast cancel: if move or other ability issued, cancel Q ---
      if (Math.abs(moveX) > 0.2 || Math.abs(moveY) > 0.2 || useE > 0.5 || useR > 0.5 || trap > 0.5 || recall > 0.5) {
        this.qWindup = 0; // Cancel Q
        this.qActive = false;
        this.qProjectile = null;
        // Optionally: play cancel animation or sound
        return;
      }
      this.qWindup -= delta;
      if (this.qWindup <= 0) {
        // Fire Q projectile using learned angle
        let angle = this.qAngle * Math.PI; // Convert from [-1,1] to radians
        this.qActive = true;
        this.qProjectile = new QProjectile(this, this.x, this.y, angle);
        projectiles.push(this.qProjectile);
        this.qTimer = Q_COOLDOWN;
      }
      // --- Q pre-fire line indicator ---
      if (typeof ctx !== 'undefined') {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#00bcd4';
        ctx.lineWidth = 5;
        ctx.setLineDash([12, 10]);
        let angle = this.qAngle * Math.PI;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(angle) * Q_RANGE, this.y + Math.sin(angle) * Q_RANGE);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
      return; // Can't auto or cast other abilities during Q windup
    }
    // Q cast trigger
    if (useQ && this.qTimer <= 0 && !this.qActive && this.qWindup <= 0) {
      if (this.spendMana(50)) {
        this.qAttempts++;
        this.qWindup = Q_CAST_TIME;
        return; // Start windup, can't do other actions
      }
    }

    // Attack logic
    if (this.windupTimer > 0) {
      this.windupTimer -= delta;
      if (this.windupTimer <= 0 && this.pendingAttack) {
        const { target, damage, isHeadshot } = this.pendingAttack;
        if (target && target.hp > 0) {
          // Prevent attacking own turret
          if (target instanceof Turret && target.team === this.team) {
            this.pendingAttack = null;
            return;
          }
          const targetId = target instanceof Minion ? target.id : null;
          // Apply damage immediately to ensure it always happens
          let realTarget = target;
          if (targetId) {
            realTarget = minions.find(m => m.id === targetId) || target;
          }
          if (realTarget && realTarget.hp > 0) {
            if (realTarget instanceof Minion) {
              console.log(`Minion ${realTarget.id} damaged: HP before=${realTarget.hp}, damage=${damage}`);
            }
            realTarget.hp -= damage;
            if (realTarget.hp < 0) realTarget.hp = 0;
            if (realTarget.hp === 0 && realTarget instanceof Minion) realTarget.alive = false;
            if (realTarget instanceof Minion) {
              console.log(`Minion ${realTarget.id} after: HP=${realTarget.hp}, alive=${realTarget.alive}`);
            }
            this.damageDealt += damage;
            if (realTarget instanceof Turret) this.turretDamage += damage;
            if (realTarget === nexuses[0] || realTarget === nexuses[1]) this.nexusDamage += damage;
            // Enhanced particle effects for damage
            if (realTarget instanceof Minion) {
              realTarget.flashColor = `hsl(${Math.floor(Math.random() * 360)}, 100%, 60%)`;
              realTarget.flashTimer = 0.18;
            } else {
              spawnDamageParticles(realTarget.x, realTarget.y, damage, false);
            }
            // --- Kiting bonus: reward for dealing damage from a distance ---
            if (realTarget && realTarget !== this && typeof realTarget.x === 'number' && typeof realTarget.y === 'number') {
              const dist = Math.hypot(this.x - realTarget.x, this.y - realTarget.y);
              // Only reward if target is not a turret or nexus
              if (!(realTarget instanceof Turret) && realTarget !== nexuses[0] && realTarget !== nexuses[1]) {
                // Bonus: up to +2.0 fitness per 100 units, capped at attack range (10x original)
                const maxRange = this.attackRange;
                const bonus = Math.min(dist, maxRange) / maxRange * 2.0 * damage;
                this.fitness += bonus;
              }
            }
            if (realTarget instanceof CaitlynAI && realTarget.team !== this.team) {
              realTarget.lastHitBy = this;
            }
          }
          // Still create projectile for visual effect
          basicProjectiles.push(new BasicProjectile(this.x, this.y, target.x, target.y, this.color, () => {
            // Projectile hit callback - damage already applied, just for visual effects
          }, isHeadshot, target, damage));
        }
        this.pendingAttack = null;
      }
      return; // Can't move or attack during windup
    }
    const dist = target ? Math.hypot(target.x - this.x, target.y - this.y) : Infinity;
    let attackRange = this.attackRange;
    if (target && (target.trapped || target.netted)) attackRange = HEADSHOT_RANGE;
    if (doAttack && target && this.attackTimer <= 0 && dist <= attackRange) {
      this.attackAttempts++;
      let damage = this.getAD();
      let isHeadshot = false;
      if (this.headshotReady || (target.trapped || target.netted)) {
        damage += Math.round(this.getAD() * HEADSHOT_BONUS_MULT);
        this.headshotReady = false;
        this.basicAttackCount = 0;
        isHeadshot = true;
      } else {
        this.basicAttackCount++;
        if (inBrush(this.x, this.y)) this.basicAttackCount++;
        const stacksNeeded = inBrush(this.x, this.y) ? HEADSHOT_STACKS_BRUSH : HEADSHOT_STACKS_NEEDED;
        if (this.basicAttackCount >= stacksNeeded) {
          this.headshotReady = true;
        }
      }
      this.windupTimer = this.attackWindup;
      this.pendingAttack = { target, damage, isHeadshot };
      this.attackTimer = this.attackDelay;
      // If attacking a minion, set lastHitBy
      if (target && target instanceof Minion) target.lastHitBy = this;
      return;
    } else {
      // --- Advanced kiting logic ---
      let speed = this.moveSpeed * parseFloat(speedSlider.value);
      if (this.slowTimer > 0) speed *= E_SLOW_AMOUNT;
      let moveVecX = 0, moveVecY = 0;
      let meleeThreats = minions.filter(m => m.alive && m.team !== this.team && (m.type === 'melee' || m.type === 'super') && Math.hypot(m.x - this.x, m.y - this.y) < this.attackRange * 1.1);
      // Calculate safe direction away from all melee threats
      let threatVecX = 0, threatVecY = 0;
      for (const m of meleeThreats) {
        const dx = this.x - m.x;
        const dy = this.y - m.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 1e-3) {
          threatVecX += dx / (dist * dist); // Weight by inverse square distance
          threatVecY += dy / (dist * dist);
        }
      }
      // Avoid walking into turrets
      let avoidTurretX = 0, avoidTurretY = 0;
      for (const t of turrets) {
        if (t.team !== this.team) {
          const turretDist = Math.hypot(this.x - t.x, this.y - t.y) - t.range;
          if (turretDist < 40) {
            const tx = this.x - t.x;
            const ty = this.y - t.y;
            const tlen = Math.hypot(tx, ty);
            if (tlen > 1e-3) {
              avoidTurretX += tx / tlen;
              avoidTurretY += ty / tlen;
            }
          }
        }
      }
      // Avoid minions (collision avoidance)
      let avoidMinionX = 0, avoidMinionY = 0;
      for (const m of minions) {
        if (m.alive && Math.hypot(this.x - m.x, this.y - m.y) < 32) {
          avoidMinionX += (this.x - m.x);
          avoidMinionY += (this.y - m.y);
        }
      }
      // Strafe direction alternates every second
      if (!this._strafeDir || Math.floor(performance.now() / 1000) % 2 === 0) {
        this._strafeDir = 1;
      } else {
        this._strafeDir = -1;
      }
      // Main movement logic
      if (this.attackTimer > 0 && (meleeThreats.length > 0 || (target && Math.hypot(target.x - this.x, target.y - this.y) < this.attackRange * 0.9))) {
        // Kite away from all melee threats (or target if no melee)
        if (threatVecX !== 0 || threatVecY !== 0) {
          moveVecX = threatVecX + avoidTurretX * 0.7 + avoidMinionX * 0.2;
          moveVecY = threatVecY + avoidTurretY * 0.7 + avoidMinionY * 0.2;
        } else if (target) {
          // Fallback: kite from target
          const dx = this.x - target.x;
          const dy = this.y - target.y;
          const len = Math.hypot(dx, dy);
          if (len > 1e-3) {
            moveVecX = dx / len + avoidTurretX * 0.7 + avoidMinionX * 0.2;
            moveVecY = dy / len + avoidTurretY * 0.7 + avoidMinionY * 0.2;
          }
        }
      } else if (target) {
        // In range: strafe
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const len = Math.hypot(dx, dy);
        let perpX = -dy / (len || 1);
        let perpY = dx / (len || 1);
        moveVecX = perpX * this._strafeDir + avoidTurretX * 0.7 + avoidMinionX * 0.2;
        moveVecY = perpY * this._strafeDir + avoidTurretY * 0.7 + avoidMinionY * 0.2;
        // If out of range, move toward target
        if (len > this.attackRange * 0.98) {
          moveVecX = dx / len + avoidTurretX * 0.7 + avoidMinionX * 0.2;
          moveVecY = dy / len + avoidTurretY * 0.7 + avoidMinionY * 0.2;
        }
      } else {
        // No target: wander using neural net output, but keep moving
        moveVecX = moveX + avoidTurretX * 0.7 + avoidMinionX * 0.2;
        moveVecY = moveY + avoidTurretY * 0.7 + avoidMinionY * 0.2;
      }
      // Normalize movement vector
      const mlen = Math.hypot(moveVecX, moveVecY);
      if (mlen > 1e-3) {
        moveVecX /= mlen;
        moveVecY /= mlen;
      }
      // Avoid map edges
      const edgeBuffer = 40;
      if (this.x < edgeBuffer) moveVecX += 0.5;
      if (this.x > CANVAS_WIDTH - edgeBuffer) moveVecX -= 0.5;
      if (this.y < edgeBuffer) moveVecY += 0.5;
      if (this.y > CANVAS_HEIGHT - edgeBuffer) moveVecY -= 0.5;
      // Reduce random jitter for more purposeful movement
      const jitter = 0.01;
      let newX = this.x + (moveVecX + (Math.random() - 0.5) * jitter) * speed * delta;
      let newY = this.y + (moveVecY + (Math.random() - 0.5) * jitter) * speed * delta;
      if (!isBlockedMap(newX, newY)) { this.x = newX; this.y = newY; }
      // Clamp
      if (!isFinite(this.x) || !isFinite(this.y)) {
        this.x = Math.max(0, Math.min(CANVAS_WIDTH, isFinite(this.x) ? this.x : 400));
        this.y = Math.max(0, Math.min(CANVAS_HEIGHT, isFinite(this.y) ? this.y : 300));
      } else {
        this.x = Math.max(0, Math.min(CANVAS_WIDTH, this.x));
        this.y = Math.max(0, Math.min(CANVAS_HEIGHT, this.y));
      }
    }
    // Track minimum distance to enemy Nexus
    if (this.team === 0 || this.team === 1) {
      const enemyNexus = nexuses[1 - this.team];
      const distToNexus = Math.hypot(this.x - enemyNexus.x, this.y - enemyNexus.y);
      if (distToNexus < this.minDistToEnemyNexus) this.minDistToEnemyNexus = distToNexus;
    }
    // Reward for standing in bush
    if (inBrush(this.x, this.y)) this.fitness += 0.01 * delta;
    // DPM fitness: add damage per second
    this.fitness += (this.damageDealt / 60) * delta;
    // Track bush time
    if (inBrush(this.x, this.y)) this.bushTime += delta;
    // Track idle time (not moving or attacking for >5s)
    const distMoved = Math.hypot(this.x - this.lastPosition.x, this.y - this.lastPosition.y);
    if (distMoved > 2 || this.attackTimer > 0) {
      this.lastActiveTime = now;
    } else if (now - this.lastActiveTime > 5) {
      this.idleTime += delta;
    }
    this.lastPosition.x = this.x;
    this.lastPosition.y = this.y;

    // E cooldown
    this.eCooldown -= delta;
    if (this.eSlowTimer > 0) {
      this.eSlowTimer -= delta;
      if (this.eSlowTimer <= 0) this.eSlowedBy = null;
    }
    // Use E if off cooldown, not dead, and target in range (for now, use randomly for demo)
    if (!this.dead && this.eCooldown <= 0 && this.useEIntent > 0.5) {
      if (this.spendMana(75)) {
        // Fire net in a direction (for now, away from nearest enemy)
        let angle = Math.random() * Math.PI * 2;
        if (others && others.length > 0) {
          // Fire away from nearest enemy
          let nearest = others.filter(o => o.team !== this.team && o.hp > 0)[0];
          if (nearest) angle = Math.atan2(this.y - nearest.y, this.x - nearest.x);
        }
        netProjectiles.push(new NetProjectile(this, this.x, this.y, angle));
        // Knock Caitlyn back
        this.x += Math.cos(angle) * -60;
        this.y += Math.sin(angle) * -60;
        this.eCooldown = 16; // fixed cooldown for now
      }
    }
    // R cooldown
    this.rCooldown -= delta;
    if (this.rCooldown < 0) this.rCooldown = 0;
    if (this.rChanneling) {
      this.rChannelTime -= delta;
      if (this.rChannelTime <= 0 && this.rTarget && this.rTarget.hp > 0) {
        // Fire ult projectile (after channel)
        projectiles.push(new UltProjectile(this, this.x, this.y, this.rTarget));
        this.rCooldown = 60; // 60s cooldown
        this.rChanneling = false;
        this.rTarget = null;
      }
      return; // Can't do anything else while channeling
    }
    // If useR and R is ready, find target and start channel
    if (useR && this.rCooldown <= 0 && !this.rChanneling) {
      if (this.spendMana(100)) {
        // Find enemy Caitlyns in range (3500 units)
        const enemiesInRange = caitlyns.filter(c => c.team !== this.team && c.hp > 0 && c.constructor && c.constructor.name === 'CaitlynAI' && Math.hypot(c.x - this.x, c.y - this.y) < 3500 * GAME_UNIT_TO_PX);
        if (enemiesInRange.length > 0) {
          // Select target based on rTarget output
          const idx = Math.floor(Math.abs(rTarget) * enemiesInRange.length) % enemiesInRange.length;
          const candidate = enemiesInRange[idx];
          // Final strict check: only allow enemy Caitlyns, never turrets/minions/other
          if (candidate && candidate.team !== this.team && candidate !== this && candidate.constructor && candidate.constructor.name === 'CaitlynAI') {
            this.rTarget = candidate;
            this.rChanneling = true;
            this.rChannelTime = 3.0; // 3s channel (was 1.0)
          } else {
            if (typeof debugOverlay !== 'undefined' && debugOverlay) debugOverlay.textContent = 'R target error: tried to ult non-enemy CaitlynAI (turret/minion/other)!';
            this.rTarget = null;
            this.rChanneling = false;
          }
        }
      }
    }
    // Auto-recall if gold >= 500, not dead, not recalling, not at base
    if (!this.dead && !this.isRecalling && this.gold >= 500 && Math.hypot(this.x - NEXUS_POS[this.team].x, this.y - NEXUS_POS[this.team].y) > NEXUS_RADIUS + 10) {
      this.startRecall();
    }
    // --- Failsafe: Always decrement windupTimer and trapRootTimer, and forcibly reset if stuck ---
    if (this.windupTimer > 0) {
      this.windupTimer -= delta;
      if (this.windupTimer > 2) this.windupTimer = 0; // Failsafe: never stuck >2s
    }
    if (this.trapRootTimer > 0) {
      this.trapRootTimer -= delta;
      if (this.trapRootTimer > 2) this.trapRootTimer = 0; // Failsafe: never stuck >2s
    }
    // --- Failsafe: forcibly reset isRecalling and rChanneling if stuck ---
    if (this.isRecalling) {
      if (!this._recallStartTime) this._recallStartTime = now;
      if (now - this._recallStartTime > 10) {
        this.isRecalling = false;
        this.recallTimer = 0;
        this._recallStartTime = null;
      }
    } else {
      this._recallStartTime = null;
    }
    if (this.rChanneling) {
      if (!this._rChannelStartTime) this._rChannelStartTime = now;
      if (now - this._rChannelStartTime > 10) {
        this.rChanneling = false;
        this.rChannelTime = 0;
        this.rTarget = null;
        this._rChannelStartTime = null;
      }
    } else {
      this._rChannelStartTime = null;
    }
    // --- Hard failsafe: forcibly nudge Caitlyn if stuck for 5s ---
    if (!this._lastNudgeTime) this._lastNudgeTime = now;
    const nudgeDistMoved = Math.hypot(this.x - this.lastPosition.x, this.y - this.lastPosition.y);
    if (nudgeDistMoved < 2 && now - this._lastNudgeTime > 5) {
      // Nudge in a random direction
      const angle = Math.random() * 2 * Math.PI;
      this.x += Math.cos(angle) * 20;
      this.y += Math.sin(angle) * 20;
      this._lastNudgeTime = now;
    } else if (nudgeDistMoved >= 2) {
      this._lastNudgeTime = now;
    }
    // In CaitlynAI.update, at the start of each frame, regen mana
    this.mana = Math.min(this.maxMana, this.mana + this.manaRegen * delta);
  }

  draw() {
    if (this.hp <= 0 && !this.dead) return;
    // Draw healthbar
    drawHealthbar(this.x, this.y - CAITLYN_RADIUS - 40, 44, 7, this.hp, CAITLYN_BASE_HP + this.getBonusHP());
    // Draw attack range circle
    ctx.save();
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.attackRange, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,0,0.25)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 6]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
    if (this.dead) {
      ctx.save();
      ctx.font = 'bold 16px sans-serif';
      ctx.fillStyle = TEAM_COLORS[this.team];
      ctx.textAlign = 'center';
      ctx.fillText('Respawn: ' + Math.ceil(this.respawnTimer), this.x, this.y - CAITLYN_RADIUS - 18);
      ctx.restore();
      return;
    }
    if (this.isRecalling) {
      // Blue recall circle
      ctx.save();
      ctx.beginPath();
      ctx.arc(this.x, this.y, CAITLYN_RADIUS + 18, 0, Math.PI * 2);
      ctx.strokeStyle = '#2196f3';
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.7;
      ctx.stroke();
      // Channeling animation: rotating arc
      const t = performance.now() / 1000;
      ctx.beginPath();
      ctx.arc(this.x, this.y, CAITLYN_RADIUS + 24, t % (2 * Math.PI), t % (2 * Math.PI) + Math.PI / 2);
      ctx.strokeStyle = '#00eaff';
      ctx.lineWidth = 5;
      ctx.globalAlpha = 0.8;
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
      // Recall timer text
      ctx.save();
      ctx.font = 'bold 16px sans-serif';
      ctx.fillStyle = '#00bcd4';
      ctx.textAlign = 'center';
      ctx.fillText('Recalling: ' + Math.ceil(this.recallTimer), this.x, this.y - CAITLYN_RADIUS - 18);
      ctx.restore();
      return;
    }
    // Draw items as icons above head
    if (this.items.length > 0) {
      ctx.save();
      ctx.textAlign = 'center';
      let iconY = this.y - CAITLYN_RADIUS - 36;
      let iconX = this.x;
      let iconSize = 24;
      let iconGap = 28;
      let drawn = 0;
      for (const it of this.items) {
        if (it.icon.endsWith('.png')) {
          let img = CaitlynAI.itemIcons[it.icon];
          if (!img) {
            img = new window.Image();
            img.src = it.icon;
            CaitlynAI.itemIcons[it.icon] = img;
          }
          ctx.drawImage(img, iconX + (drawn - (this.items.length-1)/2) * iconGap - iconSize/2, iconY - iconSize/2, iconSize, iconSize);
        } else {
          ctx.font = '20px sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText(it.icon, iconX + (drawn - (this.items.length-1)/2) * iconGap, iconY);
        }
        drawn++;
      }
      ctx.restore();
    }
    if (this.isRecalling) return;
    try {
      // Log every draw call for debugging
      // console.log('CaitlynAI.draw called', this.x, this.y);
      // ABSOLUTE FIRST: Guard against NaN/invalid positions
      if (!isFinite(this.x) || !isFinite(this.y)) {
        console.error('NaN position in draw for Caitlyn:', this, new Error().stack);
        this.x = 400;
        this.y = 300;
        // Draw a red square as a visible error marker
        ctx.save();
        ctx.fillStyle = 'red';
        ctx.fillRect(390, 290, 20, 20);
        ctx.restore();
        return;
      }
      // Defensive: check before using in gradient
      let cx = this.x, cy = this.y, r1 = CAITLYN_RADIUS / 2, r2 = CAITLYN_RADIUS;
      if (![cx, cy, r1, r2].every(isFinite)) {
        console.error('Non-finite value for gradient:', {cx, cy, r1, r2}, this, new Error().stack);
        // Draw a yellow square as a visible error marker
        ctx.save();
        ctx.fillStyle = 'yellow';
        ctx.fillRect(390, 290, 20, 20);
        ctx.restore();
        return;
      }
      // Draw Caitlyn with enhanced graphics
      const SPRITE_SIZE = 64;
      let drawX = this.x - SPRITE_SIZE / 2;
      let drawY = this.y - SPRITE_SIZE / 2;
      
      // Attack animation and effects
      let scale = 1;
      if (this.windupTimer > 0 || this.attackTimer > this.attackDelay - 0.15) scale = 1.15;
      
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(scale, scale);
      ctx.translate(-this.x, -this.y);
      
      // Enhanced glow effect for Caitlyn with animations
      const time = performance.now() / 1000;
      const pulse = Math.sin(time * 3) * 0.3 + 1;
      const glowIntensity = Math.sin(time * 2) * 0.5 + 0.5;
      
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 25 + glowIntensity * 15;
      
      if (caitlynImgLoaded) {
        ctx.drawImage(caitlynImg, drawX, drawY, SPRITE_SIZE, SPRITE_SIZE);
      } else {
        // Enhanced fallback: draw modern circle with effects
        let gradient = ctx.createRadialGradient(cx, cy, r1, cx, cy, r2);
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(0.7, this.color);
        gradient.addColorStop(1, '#2c3e50');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, CAITLYN_RADIUS * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        // Add border glow with animation
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Energy particles around Caitlyn
        if (this.hp > 0 && !this.dead) {
          const particleCount = Math.floor(this.hp / 20);
          for (let i = 0; i < particleCount; i++) {
            const angle = (time * 2 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
            const radius = CAITLYN_RADIUS + 8 + Math.sin(time * 4 + i) * 3;
            const px = this.x + Math.cos(angle) * radius;
            const py = this.y + Math.sin(angle) * radius;
            
            ctx.fillStyle = this.team === 0 ? '#74b9ff' : '#fd79a8';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Add team indicator glow
      ctx.shadowBlur = 0;
      ctx.strokeStyle = this.team === 0 ? '#3498db' : '#e74c3c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, CAITLYN_RADIUS + 5, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.restore();
      // Enhanced HP display with health bar
      const healthPercent = this.hp / this.maxHp;
      const barWidth = 40;
      const barHeight = 6;
      const barY = this.y - CAITLYN_RADIUS - 15;
      
      // Health bar background
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
      
      // Health bar fill with gradient
      const gradient = ctx.createLinearGradient(this.x - barWidth/2, barY, this.x + barWidth/2, barY);
      if (healthPercent > 0.6) {
        gradient.addColorStop(0, '#27ae60');
        gradient.addColorStop(1, '#2ecc71');
      } else if (healthPercent > 0.3) {
        gradient.addColorStop(0, '#f39c12');
        gradient.addColorStop(1, '#e67e22');
      } else {
        gradient.addColorStop(0, '#e74c3c');
        gradient.addColorStop(1, '#c0392b');
      }
      
      ctx.fillStyle = gradient;
      ctx.fillRect(this.x - barWidth/2, barY, barWidth * healthPercent, barHeight);
      
      // Health bar border
      ctx.strokeStyle = '#2c3e50';
      ctx.lineWidth = 1;
      ctx.strokeRect(this.x - barWidth/2, barY, barWidth, barHeight);
      
      // HP number with glow
      // ctx.fillStyle = 'white';
      // ctx.font = 'bold 14px sans-serif';
      // ctx.shadowColor = 'black';
      // ctx.shadowBlur = 3;
      // ctx.textAlign = 'center';
      // ctx.fillText(Math.round(this.hp), this.x, this.y + 5);
      // Draw headshot ready indicator as a red circle outline
      if (this.headshotReady) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, CAITLYN_RADIUS + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.lineWidth = 1;
      }
      // Draw attack range (highly visible)
      console.log('Caitlyn attack range:', this.attackRange);
      ctx.save();
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.attackRange, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 6]);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
      // Draw headshot stacks
      const stacksNeeded = inBrush(this.x, this.y) ? HEADSHOT_STACKS_BRUSH : HEADSHOT_STACKS_NEEDED;
      const basicAttackCount = typeof this.basicAttackCount === 'number' ? this.basicAttackCount : 0;
      ctx.fillStyle = this.headshotReady ? 'red' : 'orange';
      ctx.font = '12px sans-serif';
      ctx.fillText(`HS: ${basicAttackCount}/${stacksNeeded}`, this.x - 20, this.y + 24);
      // Draw trap/netted indicator
      if (this.trapped || this.netted) {
        ctx.fillStyle = '#00ffff';
        ctx.font = '14px sans-serif';
        ctx.fillText('â˜£', this.x - 7, this.y - CAITLYN_RADIUS - 10);
      }
      // Draw a line to target if alive
      if (this.targetIdx >= 0 && caitlyns[this.targetIdx] && caitlyns[this.targetIdx].hp > 0) {
        ctx.save();
        ctx.strokeStyle = this.color;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(caitlyns[this.targetIdx].x, caitlyns[this.targetIdx].y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
      // Draw team label above head
      ctx.save();
      ctx.font = 'bold 16px sans-serif';
      ctx.fillStyle = TEAM_COLORS[this.team];
      ctx.textAlign = 'center';
      ctx.fillText(this.team === 0 ? 'T1' : 'T2', this.x, this.y - CAITLYN_RADIUS - 18);
      ctx.restore();
      // ... existing code ...
      // In CaitlynAI.draw, after drawing the team label above head:
      if (window.showPlayerGold) {
        ctx.save();
        ctx.font = 'bold 15px monospace';
        ctx.fillStyle = '#ffd700';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 4;
        ctx.fillText(Math.floor(this.gold) + 'g', this.x, this.y - CAITLYN_RADIUS - 32);
        ctx.restore();
      }
      // ... existing code ...
      // In CaitlynAI.draw, show XP, level, and mana bar below HP
      ctx.save();
      ctx.font = 'bold 12px sans-serif';
      ctx.fillStyle = '#00bcd4';
      ctx.textAlign = 'center';
      ctx.fillText(`Lv${this.level}  XP:${this.xp}`, this.x, this.y + 36);
      // Mana bar
      const manaPercent = this.mana / this.maxMana;
      ctx.fillStyle = '#2196f3';
      ctx.fillRect(this.x - 20, this.y + 40, 40 * manaPercent, 4);
      ctx.strokeStyle = '#1976d2';
      ctx.strokeRect(this.x - 20, this.y + 40, 40, 4);
      ctx.restore();
    } catch (e) {
      console.error('Exception in CaitlynAI.draw:', e, this, new Error().stack);
    }
    // In CaitlynAI.draw, add R channeling visual
    if (this.rChanneling && this.rTarget && this.rTarget.hp > 0) {
      // Draw thick, animated line from Caitlyn to target
      ctx.save();
      ctx.strokeStyle = '#ffeb3b';
      ctx.lineWidth = 10;
      ctx.globalAlpha = 0.7 + 0.3 * Math.sin(performance.now() / 100);
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.rTarget.x, this.rTarget.y);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.rTarget.x, this.rTarget.y);
      ctx.stroke();
      ctx.restore();
      // Draw floating 'ULT!' label above Caitlyn
      ctx.save();
      ctx.font = 'bold 24px sans-serif';
      ctx.fillStyle = '#ffeb3b';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 6;
      ctx.fillText('ULT!', this.x, this.y - CAITLYN_RADIUS - 60);
      ctx.restore();
      // Draw BFSword icon above head if she has it
      if (this.hasBFSword && typeof bfswordImgLoaded !== 'undefined' && bfswordImgLoaded) {
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.drawImage(bfswordImg, this.x - 18, this.y - CAITLYN_RADIUS - 90, 36, 36);
        ctx.restore();
      }
    }
    // In CaitlynAI.draw, only show R range indicator if R is off cooldown and not channeling
    if (this.rCooldown <= 0 && !this.rChanneling) {
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 3500 * GAME_UNIT_TO_PX, 0, Math.PI * 2);
      ctx.strokeStyle = '#ffeb3b';
      ctx.lineWidth = 6;
      ctx.setLineDash([18, 12]);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.restore();
    }
    // In CaitlynAI.draw, add a speech bubble above head showing what they're 'thinking'
    let thought = '';
    if (this.dead) {
      thought = '...';
    } else if (this.rChanneling) {
      thought = 'Channeling R!';
    } else if (this.rCooldown <= 0) {
      thought = 'Ult Ready!';
    } else if (this.qActive || this.qWindup > 0) {
      thought = 'Casting Q';
    } else if (this.attackIntent > 0.5) {
      thought = 'Attacking';
    } else if (this.trapIntent > 0.5) {
      thought = 'Placing Trap';
    } else if (this.useEIntent > 0.5) {
      thought = 'Using E';
    } else if (this.moveX !== 0 || this.moveY !== 0) {
      thought = 'Moving';
    } else {
      thought = '...';
    }
    if (thought !== this.lastThought) {
      this.lastThought = thought;
      this.thoughtTimer = 2.0; // seconds
    }
    if (this.thoughtTimer > 0) {
      this.thoughtTimer -= 1/60; // assuming 60 FPS, adjust if needed
      ctx.save();
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.92;
      // Draw speech bubble
      const bubbleY = this.y - CAITLYN_RADIUS - 70;
      const textWidth = ctx.measureText(thought).width;
      ctx.beginPath();
      ctx.ellipse(this.x, bubbleY, textWidth/2 + 16, 18, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#222';
      ctx.globalAlpha = 1;
      ctx.fillText(thought, this.x, bubbleY + 5);
      ctx.restore();
    }
    // Draw AD above Caitlyn's head if toggle is enabled
    if (showAD) {
      ctx.save();
      ctx.font = 'bold 13px monospace';
      ctx.fillStyle = '#ff9800';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 4;
      ctx.fillText('AD:' + Math.round(this.getAD()), this.x, this.y - CAITLYN_RADIUS - 44);
      ctx.restore();
    }
  }
  // Calculate stats from items
  getBaseAD() { return CAITLYN_BASE_AD; }
  getBonusAD() { return this.items.reduce((s, it) => s + (it.ad || 0), 0); }
  getBonusHP() { return this.items.reduce((s, it) => s + (it.hp || 0), 0); }
  getBonusMS() { return this.items.reduce((s, it) => s + (it.ms || 0), 0); }
  getBonusCrit() { return this.items.reduce((s, it) => s + (it.crit || 0), 0); }
  // Add method to start recall (can be called by AI logic or UI)
  startRecall() {
    if (!this.isRecalling && !this.dead) {
      this.isRecalling = true;
      this.recallTimer = 5.0;
      this.tookDamage = false;
      console.log(`Caitlyn (team ${this.team}) started recall at (${Math.round(this.x)},${Math.round(this.y)}) with gold: ${this.gold}`);
    }
  }
  // Add gainXP and spendMana methods to CaitlynAI
  gainXP(amount) {
    this.xp += amount;
    while (this.level < 18 && this.xp >= this.xpToNext[this.level]) {
      this.level++;
      // Level up: scale stats
      this.hp += 107; // HP per level
      this.maxHp = (this.maxHp || CAITLYN_BASE_HP) + 107;
      this.attackSpeed *= 1.035; // +3.5% per level
      this.mana += 50;
      this.maxMana += 50;
      this.manaRegen += 0.14; // +0.7 per 5s
      this.levelUpEffect = 1.0; // for UI flash
    }
    if (this.level > 18) this.level = 18;
    if (this.xp > this.xpToNext[17]) this.xp = this.xpToNext[17];
  }
  spendMana(amount) {
    if (this.mana >= amount) { this.mana -= amount; return true; } return false;
  }
  getAD() {
    return this.baseAD + this.adGrowth * (this.level - 1);
  }
}

let mutationRateSlider = document.getElementById('mutationRate');
let attackBiasSlider = document.getElementById('attackBias');
let speedSlider = document.getElementById('speed');
const speed2000Btn = document.createElement('button');
speed2000Btn.textContent = '2000x';
speed2000Btn.style.marginLeft = '8px';
speed2000Btn.style.fontWeight = 'bold';
speed2000Btn.style.background = '#333';
speed2000Btn.style.color = '#fff';
speed2000Btn.style.border = '1px solid #888';
speed2000Btn.style.borderRadius = '4px';
speed2000Btn.style.font = '12px monospace';
speed2000Btn.style.padding = '2px 8px';
speed2000Btn.onclick = () => {
  speedSlider.value = 2000;
};
speedSlider.parentNode.appendChild(speed2000Btn);

// Show AD toggle
let showAD = false;
const showADBtn = document.getElementById('showADBtn');
showADBtn.onclick = () => {
  showAD = !showAD;
  showADBtn.textContent = showAD ? 'Hide AD' : 'Show AD';
};
let showFitness = false;
const showFitnessBtn = document.getElementById('showFitnessBtn');
showFitnessBtn.onclick = () => {
  showFitness = !showFitness;
  showFitnessBtn.textContent = showFitness ? 'Hide Fitness' : 'Show Fitness';
};
let showZed = false;
const showZedBtn = document.getElementById('showZedBtn');
showZedBtn.onclick = () => {
  showZed = !showZed;
  showZedBtn.textContent = showZed ? 'Show Zed: ON' : 'Show Zed: OFF';
};
let statsDiv = document.getElementById('stats');

let generation = 1;
var caitlyns = [];
let projectiles = [];
let basicProjectiles = [];

let noDamageTimer = 15; // 15 seconds timeout for inactivity
let generationStartTime = null;

// Use localStorage for brain persistence
const BRAIN_KEY = 'caitlyn_brain';
let savedBrain = null;

// --- Flexible brain migration system ---
function getRequiredBrainLength() {
  const perFrameInputs = 37; // was 35
  const frames = TEMPORAL_FRAMES;
  const numInputs = perFrameInputs * frames, H1 = 128, H2 = 128, H3 = 64, O = 11;
  return numInputs * H1 + H1 + H1 * H2 + H2 + H2 * H3 + H3 + H3 * O + O;
}
function migrateBrain(brain) {
  const len = getRequiredBrainLength();
  let out = Array.isArray(brain) ? brain.slice() : [];
  while (out.length < len) out.push(Math.random() * 2 - 1);
  while (out.length > len) out.pop();
  return out;
}
// On loadBrain, always migrate
function loadBrain() {
  try {
    const data = localStorage.getItem(BRAIN_KEY);
    if (data) {
      let loaded = JSON.parse(data);
      loaded = migrateBrain(loaded);
      savedBrain = loaded;
      console.log('Loaded saved brain from localStorage:', savedBrain);
      
      // Debug: Test what the saved brain outputs
      const testInputs = Array(35).fill(0); // All zeros as test
      const testOutput = feedforward(testInputs, savedBrain);
      console.log('Saved brain test output (all zero inputs):', testOutput.map(x => x.toFixed(3)));
      console.log('useQ value from saved brain:', testOutput[3].toFixed(3), 'threshold:', (testOutput[3] > 0.5));
    }
  } catch (e) {
    console.log('No saved brain found, starting fresh.');
  }
}
// On saveBrain, always migrate
function saveBrain(brain) {
  localStorage.setItem(BRAIN_KEY, JSON.stringify(migrateBrain(brain)));
}
// On mutation, always migrate
CaitlynAI.mutate = function(brain, rate) {
  let out = migrateBrain(brain);
  return out.map(w => w + (Math.random() * 2 - 1) * rate);
};
// On randomBrain, always use required length
CaitlynAI.randomBrain = function() {
  return Array.from({ length: getRequiredBrainLength() }, () => Math.random() * 2 - 1);
};
// --- End flexible brain migration ---

function exportBrain() {
  const data = localStorage.getItem(BRAIN_KEY);
  if (!data) return alert('No brain to export!');
  const blob = new Blob([data], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'caitlyn_brain.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

function importBrain(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const brain = JSON.parse(e.target.result);
      localStorage.setItem(BRAIN_KEY, JSON.stringify(brain));
      savedBrain = brain;
      alert('Brain imported! Reloading...');
      location.reload();
    } catch (err) {
      alert('Invalid brain file.');
    }
  };
  reader.readAsText(file);
}

function clearBrain() {
  localStorage.removeItem(BRAIN_KEY);
  savedBrain = null;
  alert('Brain cleared! Reloading...');
  location.reload();
}

// Add Export/Import buttons to UI
const uiDiv = document.getElementById('ui');
const exportBtn = document.createElement('button');
exportBtn.textContent = 'Export Brain';
exportBtn.onclick = exportBrain;
uiDiv.appendChild(exportBtn);
const importBtn = document.createElement('button');
importBtn.textContent = 'Import Brain';
importBtn.onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,application/json';
  input.onchange = e => {
    if (input.files && input.files[0]) importBrain(input.files[0]);
  };
  input.click();
};
uiDiv.appendChild(importBtn);
const clearBtn = document.createElement('button');
clearBtn.textContent = 'Clear Brain';
clearBtn.onclick = clearBrain;
uiDiv.appendChild(clearBtn);

// Chart.js metrics for team stats
let teamMetricsHistory = [];
let teamChart;

// Add team metrics chart UI
const teamGraphDiv = document.getElementById('teamGraphUI');
teamGraphDiv.innerHTML = `
  <label for="teamMetricSelect" style="color:white;margin-left:20px;">Team Metric: </label>
  <select id="teamMetricSelect">
    <option value="wins">Wins</option>
    <option value="avgDPM">Avg DPM</option>
    <option value="totalDPM">Total DPM</option>
    <option value="gold">Gold</option>
    <option value="avgRank">Grade</option>
  </select>
  <canvas id="teamMetricsChart" width="800" height="200" style="display:block;margin:10px auto 0 auto;background:#111;border-radius:8px;"></canvas>
`;

// Add 'Gold' option to the metric selector
const metricSelect = document.getElementById('teamMetricSelect');
if (![...metricSelect.options].some(opt => opt.value === 'gold')) {
  const goldOption = document.createElement('option');
  goldOption.value = 'gold';
  goldOption.textContent = 'Gold';
  metricSelect.appendChild(goldOption);
}

// Add 'Grade' option to the metric selector
if (![...metricSelect.options].some(opt => opt.value === 'avgRank')) {
  const gradeOption = document.createElement('option');
  gradeOption.value = 'avgRank';
  gradeOption.textContent = 'Grade';
  metricSelect.appendChild(gradeOption);
}

// Add 'Composite Score' option to the metric selector
if (![...metricSelect.options].some(opt => opt.value === 'avgFitness')) {
  const scoreOption = document.createElement('option');
  scoreOption.value = 'avgFitness';
  scoreOption.textContent = 'Composite Score';
  metricSelect.appendChild(scoreOption);
}

// Map rank to numeric for graphing
function rankToNumeric(rank) {
  if (rank === 'S') return 5;
  if (rank === 'A') return 4;
  if (rank === 'B') return 3;
  if (rank === 'C') return 2;
  return 1;
}

// In updateTeamMetricsChart, handle avgFitness specially
function updateTeamMetricsChart() {
  const metric = document.getElementById('teamMetricSelect').value;
  const labels = teamMetricsHistory.map(m => m.generation);
  let datasets;
  if (metric === 'avgFitness') {
    datasets = [0, 1].map(t => ({
      label: `Team ${t + 1}`,
      data: teamMetricsHistory.map((m, i) => {
        // Calculate average fitness for this team in this generation
        if (!m.avgFitness || !Array.isArray(m.avgFitness)) {
          m.avgFitness = [0, 0];
          for (let team = 0; team < 2; ++team) {
            const teamCaitlyns = (window.generationCaitlyns && window.generationCaitlyns[i]) ? window.generationCaitlyns[i][team] : [];
            m.avgFitness[team] = teamCaitlyns.length ? teamCaitlyns.reduce((s, c) => s + c.fitness, 0) / teamCaitlyns.length : 0;
          }
        }
        console.log('Graphing avgFitness for gen', i, 'team', t, ':', m.avgFitness[t]);
        return m.avgFitness[t];
      }),
      borderColor: TEAM_COLORS[t],
      backgroundColor: TEAM_COLORS[t] + '33',
      fill: true,
      tension: 0.2
    }));
  } else if (metric === 'avgRank') {
    datasets = [0, 1].map(t => ({
      label: `Team ${t + 1}`,
      data: teamMetricsHistory.map(m => rankToNumeric(m.avgRank[t])),
      borderColor: TEAM_COLORS[t],
      backgroundColor: TEAM_COLORS[t] + '33',
      fill: true,
      tension: 0.2
    }));
  } else {
    datasets = [0, 1].map(t => ({
      label: `Team ${t + 1}`,
      data: teamMetricsHistory.map(m => m[metric][t]),
      borderColor: TEAM_COLORS[t],
      backgroundColor: TEAM_COLORS[t] + '33',
      fill: true,
      tension: 0.2
    }));
  }
  if (!teamChart) {
    const ctx = document.getElementById('teamMetricsChart').getContext('2d');
    teamChart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets },
      options: {
        responsive: false,
        plugins: { legend: { labels: { color: 'white' } } },
        scales: {
          x: { ticks: { color: 'white' }, grid: { color: '#444' } },
          y: { ticks: { color: 'white' }, grid: { color: '#444' } }
        }
      }
    });
  } else {
    teamChart.data.labels = labels;
    teamChart.data.datasets = datasets;
    teamChart.update();
  }
}
document.getElementById('teamMetricSelect').addEventListener('change', updateTeamMetricsChart);

// 1. Add a 'Copy Graph Data' button to the team metrics graph section
const copyGraphBtn = document.createElement('button');
copyGraphBtn.textContent = 'Copy Graph Data';
copyGraphBtn.style.marginLeft = '20px';
copyGraphBtn.style.fontWeight = 'bold';
copyGraphBtn.style.background = '#333';
copyGraphBtn.style.color = '#fff';
copyGraphBtn.style.border = '1px solid #888';
copyGraphBtn.style.borderRadius = '4px';
copyGraphBtn.style.font = '12px monospace';
copyGraphBtn.style.padding = '2px 8px';
copyGraphBtn.onclick = () => {
  const metric = document.getElementById('teamMetricSelect').value;
  let csv = 'Generation,Team 1,Team 2\n';
  teamMetricsHistory.forEach(m => {
    csv += `${m.generation},${m[metric][0]},${m[metric][1]}\n`;
  });
  navigator.clipboard.writeText(csv);
  copyGraphBtn.textContent = 'Copied!';
  setTimeout(() => { copyGraphBtn.textContent = 'Copy Graph Data'; }, 1200);
};
document.getElementById('teamMetricSelect').parentNode.appendChild(copyGraphBtn);

// Add Show/Hide Graph button to UI
const graphToggleBtn = document.createElement('button');
graphToggleBtn.textContent = 'Hide Graph';
graphToggleBtn.style.marginTop = '8px';
graphToggleBtn.onclick = function() {
  const chart = document.getElementById('teamMetricsChart');
  if (chart.style.display === 'none') {
    chart.style.display = 'block';
    graphToggleBtn.textContent = 'Hide Graph';
  } else {
    chart.style.display = 'none';
    graphToggleBtn.textContent = 'Show Graph';
  }
};
document.getElementById('ui').appendChild(graphToggleBtn);

// UI: slider box fixed to the left, simple style
uiDiv.style.position = 'fixed';
uiDiv.style.top = '20px';
uiDiv.style.left = '20px';
uiDiv.style.width = '220px';
uiDiv.style.background = 'rgba(0,0,0,0.7)';
uiDiv.style.zIndex = '20';
uiDiv.style.maxWidth = 'none';
uiDiv.style.height = 'auto';
uiDiv.style.display = 'flex';
uiDiv.style.flexDirection = 'column';
uiDiv.style.alignItems = 'flex-start';
uiDiv.style.justifyContent = 'flex-start';
uiDiv.style.boxShadow = '';
uiDiv.style.border = '';
uiDiv.style.borderRadius = '';
uiDiv.style.padding = '';

// Team metrics graph: fixed at the top, full width, simple style
teamGraphDiv.style.position = 'fixed';
teamGraphDiv.style.top = '0';
teamGraphDiv.style.left = '0';
teamGraphDiv.style.width = '100vw';
teamGraphDiv.style.background = '#222';
teamGraphDiv.style.padding = '10px 0 0 0';
teamGraphDiv.style.zIndex = '11';
teamGraphDiv.style.borderRadius = '';
teamGraphDiv.style.boxShadow = '';
teamGraphDiv.style.border = '';
teamGraphDiv.style.maxWidth = '';
teamGraphDiv.style.maxHeight = '';
teamGraphDiv.style.right = '';
teamGraphDiv.style.bottom = '';

// Remove vignette overlay if present
const vignette = document.getElementById('vignetteOverlay');
if (vignette) vignette.remove();

// Remove all particle/overlay/advanced effect code (make spawnParticles, updateParticles, drawParticles no-ops)
function spawnParticles() {}
function updateParticles() {}
function drawParticles() {}

// Canvas background: plain color
canvas.style.background = '#222';

// Caitlyn, projectile, and bush drawing: simple, non-animated, no glows/shadows
Ability.drawProjectile = function(x, y, color, type) {
  ctx.beginPath();
  ctx.arc(x, y, type === 'Q' ? 12 : 6, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.globalAlpha = type === 'Q' ? 0.5 : 1;
  ctx.fill();
  ctx.globalAlpha = 1;
};
BasicProjectile.prototype.draw = function() {
  if (!window._projectileDebug) window._projectileDebug = [];
  window._projectileDebug.push({x: this.x, y: this.y});
  ctx.save();
  // Draw a thin, faint trail
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(this.x0, this.y0);
  ctx.lineTo(this.x, this.y);
  ctx.stroke();
  // Draw a small, simple bullet
  ctx.globalAlpha = 1;
  ctx.beginPath();
  ctx.arc(this.x, this.y, this.isHeadshot ? 7 : 5, 0, Math.PI * 2);
  ctx.fillStyle = this.isHeadshot ? '#bbb' : '#888';
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#222';
  ctx.stroke();
  ctx.restore();
};
// In the game loop, restore bush drawing:
ctx.globalAlpha = 0.25;
ctx.fillStyle = '#0a4';
for (const b of bushList) {
  ctx.beginPath();
  ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
  ctx.fill();
}
ctx.globalAlpha = 1;

// Q Projectile class
class QProjectile {
  constructor(owner, x, y, angle) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = Q_SPEED;
    this.range = Q_RANGE;
    this.width = Q_WIDTH;
    this.expanded = false;
    this.distanceTraveled = 0;
    this.alive = true;
    this.hitTargets = new Set();
  }
  update(delta) {
    if (!this.alive) return;
    const dx = Math.cos(this.angle) * this.speed * delta;
    const dy = Math.sin(this.angle) * this.speed * delta;
    this.x += dx;
    this.y += dy;
    this.distanceTraveled += Math.hypot(dx, dy);
    // Stop at edge of map
    if (this.x < 0 || this.x > CANVAS_WIDTH || this.y < 0 || this.y > CANVAS_HEIGHT || this.distanceTraveled > this.range) {
      this.alive = false;
      this.owner.qActive = false;
      return;
    }
    // Hit detection
    let hitCount = this.hitTargets.size;
    for (const c of caitlyns) {
      if (c.hp <= 0 || c.team === this.owner.team || this.hitTargets.has(c)) continue;
      let w = (hitCount === 0) ? Q_WIDTH : Q_WIDTH_EXPANDED;
      if (hitCount > 0) this.width = Q_WIDTH_EXPANDED;
      if (pointInRotatedRect(c.x, c.y, this.x, this.y, w, 1, this.angle)) {
        let dmg = Q_BASE_DAMAGE + ((CAITLYN_BASE_AD + this.owner.getBonusAD()) * Q_DAMAGE_RATIO);
        if (hitCount > 0 && !c.trapped) dmg *= Q_DAMAGE_FALLOFF;
        c.hp -= Math.round(dmg);
        if (c.hp < 0) c.hp = 0;
        if (c.hp === 0) c.alive = false;
        this.owner.damageDealt += Math.round(dmg);
        this.hitTargets.add(c);
        hitCount++;
        spawnAbilityParticles(c.x, c.y, '#00bcd4');
        spawnParticles(c.x, c.y, '#00eaff', 8, 150, 1.5, 'energy');
        if (hitCount === 1) this.width = Q_WIDTH_EXPANDED;
      }
    }
    // Minion hit detection for Q
    for (const m of minions) {
      if (m.hp <= 0 || m.team === this.owner.team || this.hitTargets.has(m)) continue;
      let w = (hitCount === 0) ? Q_WIDTH : Q_WIDTH_EXPANDED;
      if (pointInRotatedRect(m.x, m.y, this.x, this.y, w, 1, this.angle)) {
        let dmg = Q_BASE_DAMAGE + ((CAITLYN_BASE_AD + this.owner.getBonusAD()) * Q_DAMAGE_RATIO);
        if (hitCount > 0) dmg *= Q_DAMAGE_FALLOFF;
        console.log(`Q hit minion ${m.id}: HP before=${m.hp}, damage=${Math.round(dmg)}`);
        m.hp -= Math.round(dmg);
        if (m.hp < 0) m.hp = 0;
        if (m.hp === 0) m.alive = false;
        console.log(`Q after: minion ${m.id} HP=${m.hp}, alive=${m.alive}`);
        this.owner.damageDealt += Math.round(dmg);
        this.hitTargets.add(m);
        hitCount++;
        m.flashColor = `hsl(${Math.floor(Math.random() * 360)}, 100%, 60%)`;
        m.flashTimer = 0.18;
        if (hitCount === 1) this.width = Q_WIDTH_EXPANDED;
      }
    }
  }
  draw() {
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    const time = performance.now() / 1000;
    const pulse = Math.sin(time * 8) * 0.3 + 1;
    
    // Enhanced outer glow
    ctx.shadowColor = '#00bcd4';
    ctx.shadowBlur = 50;
    ctx.fillStyle = 'rgba(0,188,212,0.2)';
    ctx.fillRect(-this.width/2, -20, this.width, 40);
    
    // Draw Q body with enhanced effects
    ctx.shadowBlur = 40;
    ctx.fillStyle = 'rgba(0,188,212,0.4)';
    ctx.fillRect(-this.width/2, -16, this.width, 32);
    
    // Core energy beam with pulse
    ctx.shadowBlur = 25;
    ctx.fillStyle = '#00bcd4';
    ctx.fillRect(-this.width/2, -12, this.width, 24);
    
    // Energy pulse effect
    ctx.globalAlpha = pulse * 0.7;
    ctx.fillStyle = '#00eaff';
    ctx.fillRect(-this.width/2, -8, this.width, 16);
    
    // Border energy with glow
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#00eaff';
    ctx.lineWidth = 4;
    ctx.shadowBlur = 15;
    ctx.strokeRect(-this.width/2, -16, this.width, 32);
    
    // Enhanced particle effects along the beam
    for (let i = 0; i < 8; i++) {
      const offset = (time * 0.003 + i * 0.15) % 1;
      const px = (offset - 0.5) * this.width;
      const py = Math.sin(time * 10 + i) * 4;
      
      // Sparkle particles
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.9;
      ctx.shadowColor = '#00eaff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Energy rings
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#00eaff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(px, py, 6, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Energy field around the beam
    ctx.globalAlpha = 0.1;
    ctx.fillStyle = '#00eaff';
    ctx.fillRect(-this.width/2 - 5, -25, this.width + 10, 50);
    
    ctx.restore();
  }
}
// Helper: check if point is in rotated rectangle (for Q hitbox)
function pointInRotatedRect(px, py, cx, cy, w, h, angle) {
  // Translate point to origin
  let dx = px - cx;
  let dy = py - cy;
  // Rotate point by -angle
  let cos = Math.cos(-angle);
  let sin = Math.sin(-angle);
  let rx = dx * cos - dy * sin;
  let ry = dx * sin + dy * cos;
  // Check bounds
  return Math.abs(rx) <= w/2 && Math.abs(ry) <= 24; // 24 px vertical tolerance for Q
}

function initCaitlyns(brain) {
  try {
    caitlyns = [];
    const SPAWN_RADIUS = 120;
    for (let t = 0; t < NUM_TEAMS; ++t) {
      for (let i = 0; i < TEAM_SIZE; ++i) {
        // Randomize spawn within a circle around base
        const baseX = t === 0 ? 200 : CANVAS_WIDTH - 200;
        const baseY = t === 0 ? CANVAS_HEIGHT - 200 : 200;
        const angle = Math.random() * 2 * Math.PI;
        const radius = Math.random() * SPAWN_RADIUS;
        const x = baseX + Math.cos(angle) * radius;
        const y = baseY + Math.sin(angle) * radius;
        let c = new CaitlynAI(
          x,
          y,
          TEAM_COLORS[t],
          t,
          brain ? brain.slice() : undefined
        );
        caitlyns.push(c);
      }
    }
    // Only add Zed if showZed is true
    if (showZed) {
      let zed = new CaitlynAI(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, '#00ff00', -1, brain ? brain.slice() : undefined);
      zed.isZed = true;
      caitlyns.push(zed);
    }
  } catch (e) {
    console.error('Exception in initCaitlyns:', e, e && e.stack ? e.stack : new Error().stack);
    alert('Error initializing Caitlyns: ' + e);
  }
}

// Minion scaling per minute
function getMinionScaling(minionType, gameMinutes) {
  let scale = { hp: 0, ad: 0, gold: 0, armor: 0 };
  if (minionType === 'melee' || minionType === 'caster') {
    scale.hp = 10 * gameMinutes;
    scale.ad = 1 * gameMinutes;
    scale.gold = Math.floor(gameMinutes / 1.5); // ~1 gold per 90s
    if (minionType === 'melee') scale.armor = Math.min(15, Math.floor(gameMinutes * 0.25));
  } else if (minionType === 'cannon') {
    scale.hp = 20 * gameMinutes;
    scale.ad = 2 * gameMinutes;
    scale.gold = Math.floor(gameMinutes * 0.6); // ~1 gold per 100s
    scale.armor = Math.min(30, Math.floor(gameMinutes * 0.5));
  } else if (minionType === 'super') {
    scale.hp = 40 * gameMinutes;
    scale.ad = 4 * gameMinutes;
    scale.gold = Math.floor(gameMinutes * 1.5);
    scale.armor = Math.min(60, Math.floor(gameMinutes * 1));
  }
  return scale;
}

// Minion class refactor
class Minion {
  static nextId = 1;
  constructor(team, lane, type, spawnTime) {
    this.id = Minion.nextId++;
    this.team = team;
    this.lane = lane;
    this.type = type;
    this.spawnTime = spawnTime || 0;
    this.spawnWave = 0;
    // Defensive: check lane validity
    if (!LANE_WAYPOINTS[lane]) {
      console.error(`Invalid lane '${lane}' for minion. Defaulting to 'mid'.`);
      this.lane = 'mid';
    }
    // Defensive: check type validity
    let stats = MINION_TYPES[type];
    if (!stats) {
      console.error(`Invalid minion type '${type}' for minion. Defaulting to 'melee'.`);
      this.type = 'melee';
      stats = MINION_TYPES['melee'];
    }
    this.path = team === 0 ? LANE_WAYPOINTS[this.lane] : [...LANE_WAYPOINTS[this.lane]].reverse();
    this.pathIdx = 0;
    this.x = this.path[0]?.x ?? 0;
    this.y = this.path[0]?.y ?? 0;
    // Set stats from type
    this.radius = stats.radius;
    this.color = stats.color;
    this.baseHp = stats.baseHp;
    this.baseAd = stats.baseAd;
    this.attackSpeed = stats.attackSpeed;
    this.moveSpeed = stats.moveSpeed;
    this.range = stats.range;
    this.baseGold = stats.gold;
    this.armor = stats.armor;
    this.mr = stats.mr;
    this.xp = stats.xp;
    this.turretDmgReduction = stats.turretDmgReduction || 1.0;
    this.hp = this.baseHp;
    this.ad = this.baseAd;
    this.gold = this.baseGold;
    this.lastHitBy = null;
    this.attackTimer = 0;
    this.alive = true;
    this.targetNexus = (team === 0) ? { x: NEXUS_POS[1].x, y: NEXUS_POS[1].y } : { x: NEXUS_POS[0].x, y: NEXUS_POS[0].y };
    this.target = null;
    this.armor = stats.armor;
    this.mr = stats.mr;
    // --- Add flash effect to minion icon ---
    // In Minion class constructor, add:
    this.flashColor = null;
    this.flashTimer = 0;
    // --- End minion flash effect ---
  }
  update(delta, minions, caitlyns, nexuses, turrets, gameMinutes) {
    if (!this.alive) return;
    // Scaling
    const scale = getMinionScaling(this.type, gameMinutes);
    // (FIX APPLIED) Removed HP clamping so minions can be damaged and killed
    // this.hp = Math.min(this.hp, this.baseHp + scale.hp);
    this.ad = this.baseAd + scale.ad;
    this.gold = this.baseGold + scale.gold;
    this.armor = MINION_TYPES[this.type].armor + (scale.armor || 0);
    // Pathing
    this.attackTimer -= delta;
    if (!this.path || this.path.length < 2) return;
    if (!this.targetNexus) return;
    // Target selection: prioritize enemy minion in range, then champion, then turret, then Nexus
    let bestTarget = null;
    let bestDist = 1e9;
    // Bush vision: only target enemies in same bush or not in bush
    const myBush = whichBush(this.x, this.y);
    // 1. Enemy minion in range
    for (const other of minions) {
      if (other !== this && other.alive && other.team !== this.team) {
        const otherBush = whichBush(other.x, other.y);
        if (myBush !== -1 && otherBush !== myBush && otherBush !== -1) continue;
        const dist = Math.hypot(this.x - other.x, this.y - other.y);
        if (dist < this.range && dist < bestDist) {
          bestTarget = other;
          bestDist = dist;
        }
      }
    }
    // 2. Enemy Caitlyn in range
    if (!bestTarget) {
      for (const c of caitlyns) {
        if (c.team !== this.team && c.hp > 0) {
          const cBush = whichBush(c.x, c.y);
          if (myBush !== -1 && cBush !== myBush && cBush !== -1) continue;
          const dist = Math.hypot(this.x - c.x, this.y - c.y);
          if (dist < this.range && dist < bestDist) {
            bestTarget = c;
            bestDist = dist;
          }
        }
      }
    }
    // 3. Enemy turret in range
    if (!bestTarget) {
      for (const turret of turrets) {
        if (turret.team !== this.team && turret.hp > 0) {
          const dist = Math.hypot(this.x - turret.x, this.y - turret.y);
          if (dist < this.range + 24 && dist < bestDist) {
            bestTarget = turret;
            bestDist = dist;
          }
        }
      }
    }
    // 4. Enemy Nexus in range
    if (!bestTarget) {
      const enemyNexus = nexuses[1 - this.team];
      const dist = Math.hypot(this.x - enemyNexus.x, this.y - enemyNexus.y);
      if (dist < this.range + NEXUS_RADIUS) {
        bestTarget = enemyNexus;
        bestDist = dist;
      }
    }
    this.target = bestTarget;
    // Attack if in range
    if (this.target && this.attackTimer <= 0) {
      if (this.target.hp !== undefined) {
        let dmg = this.ad;
        // Turret damage reduction
        if (this.target instanceof Turret && this.turretDmgReduction < 1.0) {
          dmg *= this.turretDmgReduction;
        }
        // Super minion turret reduction
        if (this.type === 'super' && this.target instanceof Turret) {
          dmg *= 0.5;
        }
        this.target.hp -= dmg;
        if (this.target instanceof Nexus && this.target.hp < 0) this.target.hp = 0;
        if (this.target.hp <= 0 && this.target instanceof Minion && this.target.lastHitBy) {
          this.target.lastHitBy.gold += this.target.gold;
          this.target.lastHitBy.minionLastHits = (this.target.lastHitBy.minionLastHits || 0) + 1;
        }
      }
      this.attackTimer = 1.0 / this.attackSpeed;
    }
    // Move if not attacking
    if (!this.target) {
      // Path following: move toward next waypoint
      const nextIdx = this.pathIdx + 1;
      if (nextIdx < this.path.length) {
        const targetPt = this.path[nextIdx];
        if (!targetPt) return;
        const dx = targetPt.x - this.x;
        const dy = targetPt.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 2) {
          this.x += (dx / dist) * this.moveSpeed * delta;
          this.y += (dy / dist) * this.moveSpeed * delta;
        }
        if (dist < 20 && this.pathIdx < this.path.length - 2) this.pathIdx++;
      }
    }
    // Die if HP <= 0
    if (this.hp <= 0 && this.alive) {
      this.alive = false;
      if (this.lastHitBy && this.lastHitBy.team !== this.team) {
        this.lastHitBy.gold += this.gold;
        this.lastHitBy.minionLastHits = (this.lastHitBy.minionLastHits || 0) + 1;
      }
      // XP grant
      const xpAmount = { melee: 60, caster: 29, cannon: 92, super: 97 }[this.type] || 0;
      for (const c of caitlyns) {
        if (Math.hypot(c.x - this.x, c.y - this.y) < 1200 * GAME_UNIT_TO_PX) {
          c.gainXP(xpAmount);
        }
      }
    }
    // --- Add flash effect to minion icon ---
    // In Minion update, decrement flashTimer:
    if (this.flashTimer > 0) this.flashTimer -= delta;
    // --- End minion flash effect ---
  }
  draw() {
    if (!this.alive) return;
    drawHealthbar(this.x, this.y - this.radius - 14, 32, 6, this.hp, this.baseHp);
    ctx.save();
    if (minionImgLoaded) {
      const SPRITE_SIZE = 64;
      const minionSize = SPRITE_SIZE / 4;
      ctx.drawImage(minionImg, this.x - minionSize / 2, this.y - minionSize / 2, minionSize, minionSize);
      if (this.flashTimer > 0 && this.flashColor) {
        ctx.globalAlpha = Math.max(0.3, this.flashTimer / 0.18);
        ctx.fillStyle = this.flashColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, minionSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    } else {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.globalAlpha = 0.85;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#fff';
      ctx.stroke();
      if (this.flashTimer > 0 && this.flashColor) {
        ctx.globalAlpha = Math.max(0.3, this.flashTimer / 0.18);
        ctx.fillStyle = this.flashColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    ctx.font = 'bold 12px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(Math.round(this.hp), this.x, this.y - this.radius - 22);
    ctx.restore();
  }
}

// Nexus class
class Nexus {
  constructor(x, y, team) {
    this.x = x;
    this.y = y;
    this.team = team;
    this.hp = NEXUS_HP;
  }
  draw() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(this.x, this.y, NEXUS_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = TEAM_COLORS[this.team];
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#fff';
    ctx.stroke();
    ctx.font = 'bold 20px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText('Nexus', this.x - 28, this.y + 8);
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText(Math.round(this.hp), this.x - 18, this.y + 32);
    ctx.restore();
  }
}

// Turret class: only insta-kill Caitlyns, not minions
class Turret {
  constructor(x, y, team) {
    this.x = x;
    this.y = y;
    this.team = team;
    this.range = TURRET_RANGE;
    this.hp = 1000; // Optional: turrets can have HP if you want minions to attack them
    this.maxHp = 1000;
    this.attackCooldowns = new Map(); // Map from Caitlyn to cooldown
    this.destroyed = false;
  }
  update(caitlyns, minions) {
    // Deal fixed damage to any enemy Caitlyn in range, 1s cooldown per target
    for (const c of caitlyns) {
      if (c.team !== this.team && !c.isZed && c.hp > 0 && Math.hypot(c.x - this.x, c.y - this.y) < this.range) {
        let cd = this.attackCooldowns.get(c) || 0;
        if (cd <= 0) {
          // Spawn projectile if not already one targeting this Caitlyn from this turret
          const already = turretProjectiles.some(p => p.turret === this && p.target === c && p.alive);
          if (!already) {
            turretProjectiles.push(new TurretProjectile(this, c));
            this.attackCooldowns.set(c, 1.0); // 1s cooldown
          }
        } else {
          this.attackCooldowns.set(c, cd - 1/60); // Assume 60 FPS for cooldown decrement
        }
      } else {
        this.attackCooldowns.set(c, 0);
      }
    }
    // Apply damage when projectile reaches target
    for (const p of turretProjectiles) {
      if (p.turret === this && p.alive && p.target && !p.target.isZed && p.target.team !== this.team && Math.hypot(p.x - p.target.x, p.y - p.target.y) < 8) {
        if (p.target.hp > 0) p.target.hp -= 180;
        p.alive = false;
      }
    }
    // Minions do NOT get insta-killed
    if (this.hp <= 0 && !this.destroyed) {
      this.destroyed = true;
      // Award turret participation to Caitlyns in range
      for (const c of caitlyns) {
        if (c.team !== this.team && Math.hypot(c.x - this.x, c.y - this.y) < this.range + 40) {
          c.turretsDestroyed = (c.turretsDestroyed || 0) + 1;
        }
      }
    }
  }
  draw() {
    ctx.save();
    // Draw healthbar
    drawHealthbar(this.x, this.y - 36, 48, 8, this.hp, NEXUS_HP / 2);
    // Draw range indicator
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
    ctx.strokeStyle = this.team === 0 ? '#8e44ad' : '#e74c3c';
    ctx.globalAlpha = 0.15;
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.globalAlpha = 1;
    // Draw turret body
    ctx.beginPath();
    ctx.arc(this.x, this.y, 24, 0, Math.PI * 2);
    ctx.fillStyle = this.team === 0 ? '#8e44ad' : '#e74c3c';
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#fff';
    ctx.stroke();
    ctx.font = 'bold 14px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText('Turret', this.x - 24, this.y + 6);
    ctx.restore();
  }
}

// Nexus constants
const NEXUS_HP = 2000;
const NEXUS_RADIUS = 40;
const MINION_SPAWN_INTERVAL = 2; // seconds between minion spawns
// Nexus positions (true corners)
const NEXUS_POS = [
  { x: 0 + NEXUS_RADIUS, y: CANVAS_HEIGHT - NEXUS_RADIUS }, // Blue (bottom left)
  { x: CANVAS_WIDTH - NEXUS_RADIUS, y: 0 + NEXUS_RADIUS }   // Red (top right)
];

// Lane waypoints (aligned to new corners)
const LANE_WAYPOINTS = {
  bot: [
    { x: NEXUS_POS[0].x, y: NEXUS_POS[0].y },
    { x: 200, y: CANVAS_HEIGHT - 200 },
    { x: 400, y: CANVAS_HEIGHT - 400 },
    { x: 800, y: CANVAS_HEIGHT - 600 },
    { x: CANVAS_WIDTH - 200, y: 200 },
    { x: NEXUS_POS[1].x, y: NEXUS_POS[1].y }
  ],
  top: [
    { x: NEXUS_POS[0].x, y: NEXUS_POS[0].y },
    { x: 0 + NEXUS_RADIUS, y: 200 },
    { x: 0 + NEXUS_RADIUS, y: 0 + NEXUS_RADIUS },
    { x: 200, y: 0 + NEXUS_RADIUS },
    { x: CANVAS_WIDTH - 200, y: 0 + NEXUS_RADIUS },
    { x: NEXUS_POS[1].x, y: NEXUS_POS[1].y }
  ],
  mid: [
    { x: NEXUS_POS[0].x, y: NEXUS_POS[0].y },
    { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
    { x: NEXUS_POS[1].x, y: NEXUS_POS[1].y }
  ]
};

// Turret positions (aligned to lanes)
const TURRET_POSITIONS = [
  // Blue team turrets
  [
    // Bot lane (square contour)
    { x: 200, y: CANVAS_HEIGHT - 200 },
    { x: 400, y: CANVAS_HEIGHT - 400 },
    { x: 800, y: CANVAS_HEIGHT - 600 },
    // Top lane (square contour)
    { x: 0 + NEXUS_RADIUS, y: 200 },
    { x: 0 + NEXUS_RADIUS, y: 0 + NEXUS_RADIUS },
    { x: 200, y: 0 + NEXUS_RADIUS },
    // Mid lane (straight through center)
    { x: CANVAS_WIDTH / 4, y: CANVAS_HEIGHT * 3 / 4 },
    { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
    { x: CANVAS_WIDTH * 3 / 4, y: CANVAS_HEIGHT / 4 }
  ],
  // Red team turrets
  [
    // Bot lane (square contour)
    { x: CANVAS_WIDTH - 200, y: 200 },
    { x: CANVAS_WIDTH - 400, y: 400 },
    { x: CANVAS_WIDTH - 800, y: 600 },
    // Top lane (square contour)
    { x: CANVAS_WIDTH - NEXUS_RADIUS, y: CANVAS_HEIGHT - 200 },
    { x: CANVAS_WIDTH - NEXUS_RADIUS, y: CANVAS_HEIGHT - NEXUS_RADIUS },
    { x: CANVAS_WIDTH - 200, y: CANVAS_HEIGHT - NEXUS_RADIUS },
    // Mid lane (straight through center)
    { x: CANVAS_WIDTH * 3 / 4, y: CANVAS_HEIGHT / 4 },
    { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 },
    { x: CANVAS_WIDTH / 4, y: CANVAS_HEIGHT * 3 / 4 }
  ]
];

var nexuses = [
  new Nexus(NEXUS_POS[0].x, NEXUS_POS[0].y, 0),
  new Nexus(NEXUS_POS[1].x, NEXUS_POS[1].y, 1)
];
let minions = [];
let turrets = [];
let minionSpawnTimers = [0, 0];
let minionWaveNumbers = [0, 0]; // Track wave number for each team
const MINION_WAVE_INTERVAL = 25; // seconds
const FIRST_WAVE_TIME = 10; // seconds

// Add global array for turret projectiles
let turretProjectiles = [];

// Add global array for net projectiles
let netProjectiles = [];

function main() {
  loadBrain();
  // Initialize turrets at game start
  turrets = [];
  for (let team = 0; team < 2; ++team) {
    for (const pos of TURRET_POSITIONS[team]) {
      turrets.push(new Turret(pos.x, pos.y, team));
    }
  }
  loadTurretPositions(); // <-- ensure this is called after turrets are created
  initCaitlyns(savedBrain);
  requestAnimationFrame(gameLoop);
}

main();

let lastTime = 0;
let allowRespawn = true;
let justReset = false;

// Add Zoom to Best Caitlyn button
const zoomBtn = document.createElement('button');
zoomBtn.textContent = 'Zoom to Best Caitlyn';
zoomBtn.style.marginTop = '10px';
zoomBtn.onclick = () => {
  window.zoomToBestCaitlyn = true;
};
uiDiv.appendChild(zoomBtn);
const unzoomBtn = document.createElement('button');
unzoomBtn.textContent = 'Exit Zoom';
unzoomBtn.style.marginLeft = '10px';
unzoomBtn.onclick = () => {
  window.zoomToBestCaitlyn = false;
};
uiDiv.appendChild(unzoomBtn);

// In gameLoop, before drawing, handle zoom and camera follow
let cameraX = 0, cameraY = 0, cameraZoom = 1;

function gameLoop(timestamp) {
  try {
    if (justReset) {
      justReset = false;
      // Always re-initialize Caitlyns (including Zed) on reset
      initCaitlyns(savedBrain);
      requestAnimationFrame(gameLoop);
      return;
    }
    if (!lastTime) lastTime = timestamp;
    if (generationStartTime === null) generationStartTime = timestamp;
    const delta = ((timestamp - lastTime) / 1000) * parseFloat(speedSlider.value);
    lastTime = timestamp;
    const gameSeconds = (timestamp - generationStartTime) / 1000;
    const gameMinutes = gameSeconds / 60;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Camera transform: set before any drawing
    if (window.zoomToBestCaitlyn) {
      const best = findBestCaitlyn();
      if (best) {
        cameraZoom = 3;
        cameraX = best.x;
        cameraY = best.y;
      }
    } else {
      cameraZoom = 1;
      cameraX = CANVAS_WIDTH / 2;
      cameraY = CANVAS_HEIGHT / 2;
    }
    ctx.setTransform(cameraZoom, 0, 0, cameraZoom, CANVAS_WIDTH/2 - cameraX*cameraZoom, CANVAS_HEIGHT/2 - cameraY*cameraZoom);

    // --- Wild Rift Map Overlay ---
    function drawMapOverlay(ctx) {
      // Draw base color
      ctx.save();
      ctx.fillStyle = '#2e7d32'; // Grass/ground
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Draw river
      ctx.beginPath();
      ctx.moveTo(0, CANVAS_HEIGHT * 0.7);
      ctx.lineTo(CANVAS_WIDTH * 0.3, CANVAS_HEIGHT);
      ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT * 0.3);
      ctx.lineTo(CANVAS_WIDTH * 0.7, 0);
      ctx.closePath();
      ctx.fillStyle = '#42a5f5';
      ctx.globalAlpha = 0.5;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Draw jungle areas (left and right)
      ctx.fillStyle = '#388e3c';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(0, CANVAS_HEIGHT * 0.7);
      ctx.lineTo(CANVAS_WIDTH * 0.25, CANVAS_HEIGHT);
      ctx.lineTo(CANVAS_WIDTH * 0.45, CANVAS_HEIGHT * 0.55);
      ctx.lineTo(CANVAS_WIDTH * 0.2, CANVAS_HEIGHT * 0.3);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(CANVAS_WIDTH, CANVAS_HEIGHT * 0.3);
      ctx.lineTo(CANVAS_WIDTH * 0.75, 0);
      ctx.lineTo(CANVAS_WIDTH * 0.55, CANVAS_HEIGHT * 0.45);
      ctx.lineTo(CANVAS_WIDTH * 0.8, CANVAS_HEIGHT * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // Draw walls (simple polygons for now)
      ctx.fillStyle = '#795548';
      ctx.globalAlpha = 0.8;
      // Bottom left wall
      ctx.fillRect(0, CANVAS_HEIGHT * 0.85, CANVAS_WIDTH * 0.18, CANVAS_HEIGHT * 0.15);
      // Top right wall
      ctx.fillRect(CANVAS_WIDTH * 0.82, 0, CANVAS_WIDTH * 0.18, CANVAS_HEIGHT * 0.15);
      ctx.globalAlpha = 1;
      ctx.restore();
    }
    // ... existing code ...
    // In the main game rendering loop, at the very start (before drawing units):
    drawMapOverlay(ctx);
    // ... existing code ...

    // Draw bushes
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#0a4';
    for (const b of bushList) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Draw all traps for all Caitlyns
    caitlyns.forEach(c => c.traps.forEach(trap => trap.draw()));

    // Minion spawn logic (Wild Rift style)
    for (let t = 0; t < 2; ++t) {
      minionSpawnTimers[t] += delta;
      if ((minionWaveNumbers[t] === 0 && gameSeconds >= FIRST_WAVE_TIME) || (minionWaveNumbers[t] > 0 && minionSpawnTimers[t] >= MINION_WAVE_INTERVAL)) {
        minionWaveNumbers[t]++;
        const isLateGame = gameSeconds >= 20 * 60;
        for (const lane of LANES_LIST) {
          // Check for super minion spawn (TODO: implement inhibitor turret destroyed check)
          let spawnSuper = false; // Set to true if inhib turret destroyed in this lane
          // Standard wave: 3 melee, 3 caster
          // Every 3rd wave: 2 melee, 1 cannon, 3 caster
          // After 20 min: every wave has 1 cannon
          if (spawnSuper) {
            const minion = new Minion(t, lane, 'super', gameSeconds);
            minions.push(minion);
            console.log('Spawned super minion:', minion);
          } else {
            if (isLateGame || (minionWaveNumbers[t] >= 3 && (minionWaveNumbers[t] - 1) % 3 === 0)) {
              // 2 melee, 1 cannon, 3 caster
              for (let i = 0; i < 2; ++i) { const minion = new Minion(t, lane, 'melee', gameSeconds); minions.push(minion); console.log('Spawned melee minion:', minion); }
              const cannonMinion = new Minion(t, lane, 'cannon', gameSeconds); minions.push(cannonMinion); console.log('Spawned cannon minion:', cannonMinion);
              for (let i = 0; i < 3; ++i) { const minion = new Minion(t, lane, 'caster', gameSeconds); minions.push(minion); console.log('Spawned caster minion:', minion); }
            } else {
              // 3 melee, 3 caster
              for (let i = 0; i < 3; ++i) { const minion = new Minion(t, lane, 'melee', gameSeconds); minions.push(minion); console.log('Spawned melee minion:', minion); }
              for (let i = 0; i < 3; ++i) { const minion = new Minion(t, lane, 'caster', gameSeconds); minions.push(minion); console.log('Spawned caster minion:', minion); }
            }
            // Add extra minions to make waves bigger
            for (let i = 0; i < 2; ++i) { const minion = new Minion(t, lane, 'melee', gameSeconds); minions.push(minion); console.log('Spawned extra melee minion:', minion); }
            for (let i = 0; i < 2; ++i) { const minion = new Minion(t, lane, 'caster', gameSeconds); minions.push(minion); console.log('Spawned extra caster minion:', minion); }
          }
        }
        minionSpawnTimers[t] = 0;
      }
    }
    // Update/draw minions
    minions.forEach(m => m.update(delta, minions, caitlyns, nexuses, turrets, gameMinutes));
    minions = minions.filter(m => m.alive);
    minions.forEach(m => m.draw());
    // Update and draw turrets
    turrets.forEach(t => t.update(caitlyns, minions));
    turrets.forEach(t => t.draw());
    // Update and draw turret projectiles
    turretProjectiles.forEach(p => p.update(delta));
    turretProjectiles.forEach(p => p.draw());
    turretProjectiles = turretProjectiles.filter(p => p.alive);
    // Draw nexuses above turrets
    nexuses.forEach(n => n.draw());

    caitlyns.forEach(c => {
      // Throttle movement command
      const now = performance.now() / 1000;
      if (now - c.lastMoveCommandTime > 0.25) {
        const { moveX, moveY } = c.decide(caitlyns, minions, turrets);
        c.cachedMove.x = moveX;
        c.cachedMove.y = moveY;
        c.lastMoveCommandTime = now;
      }
      const moveX = c.cachedMove.x;
      const moveY = c.cachedMove.y;
      c.update(caitlyns, delta, projectiles, minions, turrets);
      c.draw();
      
      // Draw AD above Caitlyn's head if toggle is enabled
      if (showAD) {
        const totalAD = c.getAD() + c.getBonusAD();
        ctx.save();
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 2;
        ctx.fillText(`${totalAD} AD`, c.x, c.y - CAITLYN_RADIUS - 25);
        ctx.restore();
      }
      // Draw fitness above Caitlyn's head if toggle is enabled
      if (showFitness) {
        ctx.save();
        ctx.fillStyle = '#00e5ff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 2;
        ctx.fillText(`Fitness: ${Math.round(c.fitness)}`, c.x, c.y - CAITLYN_RADIUS - 40);
        ctx.restore();
      }
    });
    projectiles.forEach(p => { p.update(delta); p.draw(); });
    projectiles = projectiles.filter(p => p.alive);

    basicProjectiles.forEach(p => p.update(delta));
    basicProjectiles.forEach(p => p.draw());
    basicProjectiles = basicProjectiles.filter(p => p.alive);
    if (typeof debugOverlay !== 'undefined' && debugOverlay) debugOverlay.textContent = 'BasicProjectiles: ' + basicProjectiles.length;
    // Draw minions, turrets, nexuses, caitlyns
    // (already present above)
    // Now draw basic projectiles above all units
    basicProjectiles.forEach(p => p.draw());
    
    // Update and draw particle system
    particleSystem.update(delta);
    particleSystem.draw();

    // Damage detection and timer reset
    let damageDone = false;
    caitlyns.forEach(c => {
      projectiles.forEach(p => {
        if (c.hp > 0 && p.alive && Math.hypot(c.x - p.x, c.y - p.y) < CAITLYN_RADIUS + p.radius) {
          c.hp--;
          p.alive = false;
          damageDone = true;
          if (c.isRecalling) c.tookDamage = true;
        }
      });
    });
    // --- Add minion projectile collision and damage ---
    minions.forEach(m => {
      projectiles.forEach(p => {
        if (m.hp > 0 && m.alive && p.alive && Math.hypot(m.x - p.x, m.y - p.y) < m.radius + p.radius) {
          m.hp -= (p.damage !== undefined ? p.damage : 1);
          p.alive = false;
          damageDone = true;
          m.flashColor = '#fff';
          m.flashTimer = 0.18;
        }
      });
    });

    // Clamp Nexus HP to zero before checking for game end
    nexuses[0].hp = Math.max(0, nexuses[0].hp);
    nexuses[1].hp = Math.max(0, nexuses[1].hp);
    console.log('Nexus HP check:', nexuses[0].hp, nexuses[1].hp);
    if (nexuses[0].hp <= 0 || nexuses[1].hp <= 0) {
      console.log('End-of-generation logic triggered: Nexus destroyed');
      // Composite Wild Rift-style score
      for (const c of caitlyns) {
        c.unspentGold = c.gold;
        c.survived = (c.hp > 0 && !c.dead);
        c.fitness = 0;
        c.fitness += c.kills * 50;
        c.fitness += c.assists * 30;
        c.fitness -= c.deaths * 80;
        c.fitness += c.minionLastHits * 1;
        c.fitness += c.turretsDestroyed * 100;
        c.fitness += c.damageDealt * 0.1;
        c.fitness += c.goldSpent * 0.02;
        c.fitness -= Math.floor(c.idleTime / 5) * 10;
        c.fitness += c.bushTime * 0.5;
        c.fitness += c.nexusDamage * 0.2;
        c.fitness -= c.unspentGold * 0.01;
        // c.fitness += c.survived ? 50 : 0;
        c.fitness += c.turretDamage * 0.05;
      }
      let winner = caitlyns.reduce((best, c) => (c.fitness > (best?.fitness ?? -Infinity) ? c : best), null);
      const genDuration = (timestamp - generationStartTime) / 1000;
      const avgAttacks = caitlyns.reduce((s, c) => s + c.attackAttempts, 0) / caitlyns.length;
      const avgQs = caitlyns.reduce((s, c) => s + c.qAttempts, 0) / caitlyns.length;
      statsDiv.innerHTML =
        `Generation: ${generation}<br>` +
        `Avg Attacks: ${avgAttacks.toFixed(2)}<br>` +
        `Avg Qs: ${avgQs.toFixed(2)}` +
        '<br><span style="color:#f39c12">Reset due to inactivity</span>';
      // Team metrics
      let teamWins = [0, 0];
      let teamAvgDPM = [0, 0];
      let teamTotalDPM = [0, 0];
      let teamGold = [0, 0];
      // Count wins (optional, not used for evolution)
      if (winner) teamWins[winner.team] = 1;
      // Calculate DPS and total damage per team
      for (let t = 0; t < NUM_TEAMS; ++t) {
        const teamCaitlyns = caitlyns.filter(c => c.team === t);
        const dpmList = teamCaitlyns.map(c => genDuration > 0 ? c.damageDealt / (genDuration / 60) : 0);
        teamAvgDPM[t] = dpmList.reduce((s, d) => s + d, 0) / dpmList.length;
        teamTotalDPM[t] = teamCaitlyns.reduce((s, c) => s + (genDuration > 0 ? c.damageDealt / (genDuration / 60) : 0), 0);
        teamGold[t] = teamCaitlyns.reduce((s, c) => s + c.gold, 0);
      }
      // Add a function to convert fitness to a rank
      function fitnessToRank(fitness) {
        if (fitness > 900) return 'S';
        if (fitness > 700) return 'A';
        if (fitness > 500) return 'B';
        if (fitness > 300) return 'C';
        return 'D';
      }
      // In the gameLoop, after calculating team metrics, add average rank calculation:
      let teamAvgRank = [0, 0];
      for (let t = 0; t < NUM_TEAMS; ++t) {
        const teamCaitlyns = caitlyns.filter(c => c.team === t);
        const avgFitness = teamCaitlyns.reduce((s, c) => s + c.fitness, 0) / teamCaitlyns.length;
        teamAvgRank[t] = fitnessToRank(avgFitness);
      }
      if (!window.generationCaitlyns) window.generationCaitlyns = [];
      const genCaitlyns = [
        caitlyns.filter(c => c.team === 0).map(c => ({...c, fitness: c.fitness})),
        caitlyns.filter(c => c.team === 1).map(c => ({...c, fitness: c.fitness}))
      ];
      console.log('Storing generationCaitlyns:', genCaitlyns.map(team => team.map(c => c.fitness)));
      window.generationCaitlyns.push(genCaitlyns);
      teamMetricsHistory.push({
        generation,
        wins: teamWins.slice(),
        avgDPM: teamAvgDPM.slice(),
        totalDPM: teamTotalDPM.slice(),
        gold: teamGold.slice(),
        avgRank: teamAvgRank.slice()
      });
      updateTeamMetricsChart();
      if (winner) {
        saveBrain(winner.brain);
      }
      // Reset nexuses
      nexuses = [
        new Nexus(NEXUS_POS[0].x, NEXUS_POS[0].y, 0),
        new Nexus(NEXUS_POS[1].x, NEXUS_POS[1].y, 1)
      ];
      // Reset turrets
      turrets = [];
      for (let team = 0; team < 2; ++team) {
        for (const pos of TURRET_POSITIONS[team]) {
          turrets.push(new Turret(pos.x, pos.y, team));
        }
      }
      loadTurretPositions(); // <-- ensure this is called after turrets are created
      // Clear minions and reset spawn timers
      minions = [];
      minionSpawnTimers = [0, 0];
      minionWaveNumbers = [0, 0];
      initCaitlyns(winner ? winner.brain : undefined);
      projectiles = [];
      generation++;
      lastTime = 0;
      generationStartTime = null;
      justReset = true;
      requestAnimationFrame(gameLoop);
      return; // End this frame
    }
    // Restore original reset logic: all Caitlyns dead
    const aliveCaitlyns = caitlyns.filter(c => c.hp > 0 && !c.dead);
    if (aliveCaitlyns.length === 0) {
      // End generation: pass on genes of highest-grade Caitlyn
      for (const c of caitlyns) {
        c.unspentGold = c.gold;
        c.survived = (c.hp > 0 && !c.dead);
        c.fitness = 0;
        c.fitness += c.kills * 50;
        c.fitness += c.assists * 30;
        c.fitness -= c.deaths * 80;
        c.fitness += c.minionLastHits * 1;
        c.fitness += c.turretsDestroyed * 100;
        c.fitness += c.damageDealt * 0.1;
        c.fitness += c.goldSpent * 0.02;
        c.fitness -= Math.floor(c.idleTime / 5) * 10;
        c.fitness += c.bushTime * 0.5;
        c.fitness += c.nexusDamage * 0.2;
        c.fitness -= c.unspentGold * 0.01;
        // c.fitness += c.survived ? 50 : 0;
        c.fitness += c.turretDamage * 0.05;
      }
      let winner = caitlyns.reduce((best, c) => (c.fitness > (best?.fitness ?? -Infinity) ? c : best), null);
      const genDuration = (timestamp - generationStartTime) / 1000;
      const avgAttacks = caitlyns.reduce((s, c) => s + c.attackAttempts, 0) / caitlyns.length;
      const avgQs = caitlyns.reduce((s, c) => s + c.qAttempts, 0) / caitlyns.length;
      statsDiv.innerHTML =
        `Generation: ${generation}<br>` +
        `Avg Attacks: ${avgAttacks.toFixed(2)}<br>` +
        `Avg Qs: ${avgQs.toFixed(2)}` +
        '<br><span style="color:#f39c12">Reset: all Caitlyns eliminated</span>';
      // Team metrics
      let teamWins = [0, 0];
      let teamAvgDPM = [0, 0];
      let teamTotalDPM = [0, 0];
      let teamGold = [0, 0];
      if (winner) teamWins[winner.team] = 1;
      for (let t = 0; t < NUM_TEAMS; ++t) {
        const teamCaitlyns = caitlyns.filter(c => c.team === t);
        const dpmList = teamCaitlyns.map(c => genDuration > 0 ? c.damageDealt / (genDuration / 60) : 0);
        teamAvgDPM[t] = dpmList.reduce((s, d) => s + d, 0) / dpmList.length;
        teamTotalDPM[t] = teamCaitlyns.reduce((s, c) => s + (genDuration > 0 ? c.damageDealt / (genDuration / 60) : 0), 0);
        teamGold[t] = teamCaitlyns.reduce((s, c) => s + c.gold, 0);
      }
      function fitnessToRank(fitness) {
        if (fitness > 900) return 'S';
        if (fitness > 700) return 'A';
        if (fitness > 500) return 'B';
        if (fitness > 300) return 'C';
        return 'D';
      }
      let teamAvgRank = [0, 0];
      for (let t = 0; t < NUM_TEAMS; ++t) {
        const teamCaitlyns = caitlyns.filter(c => c.team === t);
        const avgFitness = teamCaitlyns.reduce((s, c) => s + c.fitness, 0) / teamCaitlyns.length;
        teamAvgRank[t] = fitnessToRank(avgFitness);
      }
      teamMetricsHistory.push({
        generation,
        wins: teamWins.slice(),
        avgDPM: teamAvgDPM.slice(),
        totalDPM: teamTotalDPM.slice(),
        gold: teamGold.slice(),
        avgRank: teamAvgRank.slice()
      });
      updateTeamMetricsChart();
      if (winner) {
        saveBrain(winner.brain);
      }
      nexuses = [
        new Nexus(NEXUS_POS[0].x, NEXUS_POS[0].y, 0),
        new Nexus(NEXUS_POS[1].x, NEXUS_POS[1].y, 1)
      ];
      turrets = [];
      for (let team = 0; team < 2; ++team) {
        for (const pos of TURRET_POSITIONS[team]) {
          turrets.push(new Turret(pos.x, pos.y, team));
        }
      }
      loadTurretPositions(); // <-- ensure this is called after turrets are created
      minions = [];
      minionSpawnTimers = [0, 0];
      minionWaveNumbers = [0, 0];
      initCaitlyns(winner ? winner.brain : undefined);
      projectiles = [];
      generation++;
      lastTime = 0;
      generationStartTime = null;
      justReset = true;
      requestAnimationFrame(gameLoop);
      return; // End this frame
    }
    // At the end of gameLoop, after all drawing:
    if (caitlyns.length === 0) {
      ctx.save();
      ctx.font = 'bold 32px sans-serif';
      ctx.fillStyle = '#ff1744';
      ctx.textAlign = 'center';
      ctx.fillText('ERROR: No Caitlyns or Zed present!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
      ctx.restore();
    }
  } catch (e) {
    console.error('Exception in gameLoop:', e, e && e.stack ? e.stack : new Error().stack);
  }
  requestAnimationFrame(gameLoop);

  // At end of gameLoop, reset transform
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  // ... existing code ...

  // --- Draw static debug circle in gameLoop ---
  // At the start of gameLoop drawing section, add:
  // Remove static green debug circle in gameLoop:
  //   ctx.save(); ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(100, 100, 30, 0, Math.PI * 2); ctx.fillStyle = '#00ff00'; ctx.fill(); ctx.restore();
  // Remove projectiles text and window._projectileDebug:
  //   if (window._projectileDebug && debugOverlay) { ... }
  // ... existing code ...

  // --- Add debug overlay div to UI ---
  // REMOVE the following block:
  // let debugOverlay = document.getElementById('debugOverlay');
  // if (!debugOverlay) {
  //   debugOverlay = document.createElement('div');
  //   debugOverlay.id = 'debugOverlay';
  //   debugOverlay.style.position = 'absolute';
  //   debugOverlay.style.top = '10px';
  //   debugOverlay.style.right = '10px';
  //   debugOverlay.style.background = 'rgba(0,0,0,0.7)';
  //   debugOverlay.style.color = '#0f0';
  //   debugOverlay.style.font = '14px monospace';
  //   debugOverlay.style.padding = '8px 12px';
  //   debugOverlay.style.zIndex = 1000;
  //   document.body.appendChild(debugOverlay);
  // }
  // --- End debug overlay div ---

  // --- In BasicProjectile.draw, update debug overlay with projectile positions ---
  // (Keep this in the BasicProjectile class, not inside gameLoop)
  class BasicProjectile {
    // ... constructor and update ...
    draw() {
      if (!window._projectileDebug) window._projectileDebug = [];
      window._projectileDebug.push({x: this.x, y: this.y});
      // ... existing draw code ...
      ctx.save();
      // Draw a thin, faint trail
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.x0, this.y0);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
      // Draw a small, simple bullet
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.isHeadshot ? 7 : 5, 0, Math.PI * 2);
      ctx.fillStyle = this.isHeadshot ? '#bbb' : '#888';
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#222';
      ctx.stroke();
      ctx.restore();
    }
  }
  // --- End projectile debug overlay ---

  // --- At the end of gameLoop, update the debug overlay with all projectile positions ---
  if (window._projectileDebug && debugOverlay) {
    if (window._projectileDebug.length > 0) {
      debugOverlay.textContent = 'Projectiles: ' + window._projectileDebug.map(p => `(${Math.round(p.x)},${Math.round(p.y)})`).join(' ');
    } else {
      debugOverlay.textContent = 'Projectiles: (none)';
    }
    window._projectileDebug = [];
  }
  // --- End gameLoop debug overlay update ---

  // --- BFSword item system ---
  const BFSWORD_AD = 40;
  const BFSWORD_ICON = 'bfsword.png';
  let bfswordImg = new Image();
  bfswordImg.src = BFSWORD_ICON;
  let bfswordImgLoaded = false;
  bfswordImg.onload = () => { bfswordImgLoaded = true; };

  // Always draw bfsword.png at the center of the screen
  if (bfswordImgLoaded) {
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.drawImage(bfswordImg, CANVAS_WIDTH / 2 - 20, CANVAS_HEIGHT / 2 - 20, 40, 40);
    ctx.restore();
  }

  // BFSword item state
  if (typeof window.bfsword === 'undefined') {
    window.bfsword = {
      x: CANVAS_WIDTH / 2,
      y: CANVAS_HEIGHT / 2,
      pickedUp: false,
      sucking: false,
      targetCaitlyn: null,
      t: 0 // animation progress
    };
  }
  let bfsword = window.bfsword;

  if (!bfsword.pickedUp) {
    // Check for Caitlyn nearby
    let nearest = null, minDist = 99999;
    for (const c of caitlyns) {
      if (c.hasBFSword) continue;
      const dist = Math.hypot(c.x - bfsword.x, c.y - bfsword.y);
      if (dist < 60 && dist < minDist) {
        nearest = c;
        minDist = dist;
      }
    }
    if (nearest) {
      bfsword.sucking = true;
      bfsword.targetCaitlyn = nearest;
    }
    if (bfsword.sucking && bfsword.targetCaitlyn) {
      // Animate toward Caitlyn
      bfsword.t += 0.08;
      bfsword.x += (bfsword.targetCaitlyn.x - bfsword.x) * 0.18;
      bfsword.y += (bfsword.targetCaitlyn.y - bfsword.y) * 0.18;
      // Draw icon at current position
      if (bfswordImgLoaded) {
        ctx.save();
        ctx.globalAlpha = 0.7 + 0.3 * Math.sin(performance.now() / 100);
        ctx.drawImage(bfswordImg, bfsword.x - 20, bfsword.y - 20, 40, 40);
        ctx.restore();
      }
      // If close enough, pick up
      if (Math.hypot(bfsword.targetCaitlyn.x - bfsword.x, bfsword.targetCaitlyn.y - bfsword.y) < 18) {
        bfsword.pickedUp = true;
        bfsword.targetCaitlyn.hasBFSword = true;
        bfsword.targetCaitlyn.bfswordAD = BFSWORD_AD;
        bfsword.targetCaitlyn.bfswordIcon = true;
      }
    } else {
      // Draw icon at static position
      if (bfswordImgLoaded) {
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.drawImage(bfswordImg, bfsword.x - 20, bfsword.y - 20, 40, 40);
        ctx.restore();
      }
      bfsword.t = 0;
    }
  }
  // Draw BFSword icon above Caitlyn's head if she has it
  for (const c of caitlyns) {
    if (c.hasBFSword && bfswordImgLoaded) {
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.drawImage(bfswordImg, c.x - 18, c.y - CAITLYN_RADIUS - 54, 36, 36);
      ctx.restore();
    }
  }
  // Add BFSword AD to Caitlyn's getBonusAD
  const origGetBonusAD = CaitlynAI.prototype.getBonusAD || function() { return this.items.reduce((s, it) => s + (it.ad || 0), 0); };
  CaitlynAI.prototype.getBonusAD = function() {
    let ad = origGetBonusAD.call(this);
    if (this.hasBFSword) ad += BFSWORD_AD;
    return ad;
  };
  // --- End BFSword item system ---

  // Draw bfsword.png at the center of the screen (debug/test)
  if (bfswordImgLoaded) {
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.drawImage(bfswordImg, CANVAS_WIDTH / 2 - 20, CANVAS_HEIGHT / 2 - 20, 40, 40);
    ctx.restore();
  }

  // --- FAIL-SAFE: Force next generation if Nexus is at 0 HP and justReset is not true ---
  // (Removed: handled in main game loop logic above)
  // ... existing code ...
}

// Static property for item icon images
CaitlynAI.itemIcons = {};

// Lane list for iteration
const LANES_LIST = ["top", "mid", "bot"];

const Q_COOLDOWN = 10; // seconds, adjust as needed for balance

document.getElementById('teamMetricsChart').style.display = 'none';
graphToggleBtn.textContent = 'Show Graph';

// Show average rank in the UI
const rankDiv = document.getElementById('teamAvgRank') || (() => {
  const d = document.createElement('div');
  d.id = 'teamAvgRank';
  d.style.color = 'white';
  d.style.marginTop = '8px';
  document.getElementById('ui').appendChild(d);
  return d;
})();
const last = teamMetricsHistory[teamMetricsHistory.length-1];
if (last && last.avgRank) {
  rankDiv.innerHTML = `Team 1 Avg Rank: <b>${last.avgRank[0]}</b> &nbsp; Team 2 Avg Rank: <b>${last.avgRank[1]}</b>`;
} else {
  rankDiv.innerHTML = '';
}

// Enhanced particle system for AAA graphics
class ParticleSystem {
  constructor() {
    this.particles = [];
  }
  
  spawnParticles(x, y, color, count, speed, duration) {
    for (let i = 0; i < count; i++) {
      this.particles.push(new Particle(x, y, color, speed, duration));
    }
  }
  
  update(delta) {
    this.particles = this.particles.filter(p => p.update(delta));
  }
  
  draw() {
    this.particles.forEach(p => p.draw());
  }
}

class Particle {
  constructor(x, y, color, speed, duration, type = 'normal') {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * speed;
    this.vy = (Math.random() - 0.5) * speed;
    this.color = color;
    this.life = duration;
    this.maxLife = duration;
    this.size = Math.random() * 4 + 2;
    this.type = type;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random() - 0.5) * 10;
    this.gravity = Math.random() * 50;
    this.pulse = Math.random() * Math.PI * 2;
  }
  
  update(delta) {
    this.x += this.vx * delta;
    this.y += this.vy * delta;
    this.vy += this.gravity * delta;
    this.life -= delta;
    this.size *= 0.98;
    this.rotation += this.rotationSpeed * delta;
    this.pulse += delta * 5;
    return this.life > 0;
  }
  
  draw() {
    const alpha = this.life / this.maxLife;
    const pulseScale = Math.sin(this.pulse) * 0.3 + 1;
    
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(pulseScale, pulseScale);
    
    if (this.type === 'sparkle') {
      // Sparkle effect
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        const x = Math.cos(angle) * this.size;
        const y = Math.sin(angle) * this.size;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    } else if (this.type === 'trail') {
      // Trail effect
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.size;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 12;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(-this.vx * 0.2, -this.vy * 0.2);
      ctx.lineTo(0, 0);
      ctx.stroke();
    } else if (this.type === 'energy') {
      // Energy effect
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(0, 0, this.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Energy ring
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = alpha * 0.5;
      ctx.beginPath();
      ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      // Normal particle with enhanced glow
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(0, 0, this.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Additional glow ring
      ctx.globalAlpha = alpha * 0.3;
      ctx.beginPath();
      ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
}

// Enhanced healthbar with modern graphics
function drawHealthbar(x, y, width, height, hp, maxHp) {
  ctx.save();
  
  // Background
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(x - width/2, y, width, height);
  
  // Border
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = 2;
  ctx.strokeRect(x - width/2, y, width, height);
  
  // Health fill with gradient
  const healthPercent = Math.max(0, Math.min(1, hp / maxHp));
  const fillWidth = width * healthPercent;
  
  let gradient;
  if (healthPercent > 0.6) {
    gradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
    gradient.addColorStop(0, '#27ae60');
    gradient.addColorStop(1, '#2ecc71');
  } else if (healthPercent > 0.3) {
    gradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
    gradient.addColorStop(0, '#f39c12');
    gradient.addColorStop(1, '#e67e22');
  } else {
    gradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
    gradient.addColorStop(0, '#e74c3c');
    gradient.addColorStop(1, '#c0392b');
  }
  
  ctx.fillStyle = gradient;
  ctx.fillRect(x - width/2, y, fillWidth, height);
  
  // Glow effect
  ctx.shadowColor = gradient;
  ctx.shadowBlur = 8;
  ctx.fillRect(x - width/2, y, fillWidth, height);
  ctx.shadowBlur = 0;
  
  ctx.restore();
}

// Enhanced spawnParticles function with multiple particle types
function spawnParticles(x, y, color, count, speed, duration, type = 'normal') {
  particleSystem.spawnParticles(x, y, color, count, speed, duration, type);
}

// Enhanced particle spawning for different effects
function spawnDamageParticles(x, y, damage, isMinion) {
  if (isMinion) {
    // Rainbow burst effect
    const count = 18;
    for (let i = 0; i < count; ++i) {
      const angle = (i / count) * 2 * Math.PI;
      const color = `hsl(${Math.floor((i / count) * 360)}, 100%, 50%)`;
      spawnParticles(x, y, color, 1, 200, 1.0, 'sparkle');
    }
  } else {
    const intensity = Math.min(damage / 100, 1);
    const count = Math.floor(intensity * 6) + 2;
    spawnParticles(x, y, '#ff4444', count, 80, 0.7, 'sparkle');
  }
}

function spawnHealParticles(x, y) {
  spawnParticles(x, y, '#44ff44', 8, 100, 2.0, 'sparkle');
  spawnParticles(x, y, '#00ffaa', 4, 80, 2.5, 'trail');
}

function spawnAbilityParticles(x, y, color) {
  spawnParticles(x, y, color, 12, 300, 1.0, 'sparkle');
  spawnParticles(x, y, '#ffffff', 6, 200, 1.5, 'trail');
}

// Global particle system
let particleSystem = new ParticleSystem();

// TurretProjectile class
class TurretProjectile {
  constructor(turret, target) {
    this.turret = turret;
    this.target = target;
    this.x = turret.x;
    this.y = turret.y;
    this.speed = 900; // px/sec
    this.alive = true;
  }
  update(delta) {
    if (!this.alive || !this.target || this.target.hp <= 0) return;
    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 8) {
      this.alive = false;
      // Damage is applied in turret logic
      return;
    }
    const move = Math.min(this.speed * delta, dist);
    this.x += (dx / dist) * move;
    this.y += (dy / dist) * move;
  }
  draw() {
    if (!this.alive) return;
    ctx.save();
    // Draw thin red laser beam from turret to target
    ctx.beginPath();
    ctx.moveTo(this.turret.x, this.turret.y);
    ctx.lineTo(this.target.x, this.target.y);
    ctx.strokeStyle = 'rgba(255,0,0,0.7)';
    ctx.lineWidth = 6;
    ctx.shadowColor = '#ff1744';
    ctx.shadowBlur = 18;
    ctx.globalAlpha = 0.7 + 0.3 * Math.sin(performance.now() / 100);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(this.turret.x, this.turret.y);
    ctx.lineTo(this.target.x, this.target.y);
    ctx.strokeStyle = '#fff';
    ctx.stroke();
    ctx.restore();
  }
}

// NetProjectile class
class NetProjectile {
  constructor(owner, x, y, angle) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = 700;
    this.range = 350;
    this.distanceTraveled = 0;
    this.radius = 12;
    this.alive = true;
  }
  update(delta, caitlyns) {
    if (!this.alive) return;
    const dx = Math.cos(this.angle) * this.speed * delta;
    const dy = Math.sin(this.angle) * this.speed * delta;
    this.x += dx;
    this.y += dy;
    this.distanceTraveled += Math.hypot(dx, dy);
    if (this.distanceTraveled > this.range) {
      this.alive = false;
      return;
    }
    // Hit detection
    for (const c of caitlyns) {
      if (c === this.owner || c.hp <= 0 || c.team === this.owner.team) continue;
      if (Math.hypot(c.x - this.x, c.y - this.y) < this.radius + CAITLYN_RADIUS) {
        // Apply magic damage and slow
        c.hp -= 120; // base magic damage (can scale if you want)
        c.eSlowTimer = 1.5;
        c.eSlowedBy = this.owner;
        this.alive = false;
        break;
      }
    }
  }
  draw() {
    if (!this.alive) return;
    ctx.save();
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = '#00eaff';
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#2196f3';
    ctx.stroke();
    ctx.restore();
  }
}

// Reset game function
function resetGame() {
  if (confirm('Are you sure you want to reset the game? This will restart the AI training.')) {
    location.reload();
  }
}

// Enhanced UI interactions (safe version)
document.addEventListener('DOMContentLoaded', function() {
  // Add hover effects to controls if they exist
  const controls = document.querySelectorAll('.control-group');
  if (controls.length > 0) {
    controls.forEach(control => {
      control.addEventListener('mouseenter', function() {
        this.style.transform = 'translateY(-2px)';
        this.style.boxShadow = '0 4px 16px rgba(52, 152, 219, 0.4)';
      });
      
      control.addEventListener('mouseleave', function() {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
      });
    });
  }
  
  // Add pulse animation to header if it exists
  const header = document.querySelector('.header h1');
  if (header) {
    header.classList.add('pulse');
  }
});

// Load Minion sprite
const minionImg = new Image();
minionImg.src = 'minion.png';
let minionImgLoaded = false;
minionImg.onload = () => { minionImgLoaded = true; };

// --- Load trap.png ---
const trapImg = new Image();
trapImg.src = 'trap.png';
let trapImgLoaded = false;
trapImg.onload = () => { trapImgLoaded = true; };
// --- End trap.png load ---

// --- 3. Add UltProjectile class ---
class UltProjectile {
  constructor(owner, x, y, target) {
    // Strict runtime check: only allow CaitlynAI targets
    if (!target || !target.constructor || target.constructor.name !== 'CaitlynAI') {
      if (typeof debugOverlay !== 'undefined' && debugOverlay) debugOverlay.textContent = 'ERROR: UltProjectile target is not CaitlynAI!';
      console.error('ERROR: UltProjectile target is not CaitlynAI!', target);
      this.alive = false;
      return;
    }
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.target = target;
    this.speed = 900 * GAME_UNIT_TO_PX;
    this.alive = true;
    this.hit = false;
    // Calculate direction
    const dx = target.x - x;
    const dy = target.y - y;
    const dist = Math.hypot(dx, dy);
    this.dirX = dx / dist;
    this.dirY = dy / dist;
  }
  update(delta) {
    if (!this.alive) return;
    // Runtime check: only update if target is CaitlynAI
    if (!this.target || !this.target.constructor || this.target.constructor.name !== 'CaitlynAI') {
      if (typeof debugOverlay !== 'undefined' && debugOverlay) debugOverlay.textContent = 'ERROR: UltProjectile update: target is not CaitlynAI!';
      console.error('ERROR: UltProjectile update: target is not CaitlynAI!', this.target);
      this.alive = false;
      return;
    }
    this.x += this.dirX * this.speed * delta;
    this.y += this.dirY * this.speed * delta;
    // Check for body block (first enemy Caitlyn in path)
    for (const c of caitlyns) {
      if (c.team !== this.owner.team && c.hp > 0 && Math.hypot(c.x - this.x, c.y - this.y) < CAITLYN_RADIUS + 8) {
        // Hit!
        let dmg = 750 + 2.0 * CAITLYN_BASE_AD;
        c.hp -= Math.round(dmg);
        this.owner.damageDealt += Math.round(dmg);
        this.alive = false;
        this.hit = true;
        // Reward for hitting with R
        this.owner.fitness = (this.owner.fitness || 0) + 100;
        // Flash effect
        c.flashColor = '#fff';
        c.flashTimer = 0.25;
        break;
      }
    }
    // Remove if out of range
    if (Math.hypot(this.x - this.owner.x, this.y - this.owner.y) > 4000 * GAME_UNIT_TO_PX) this.alive = false;
  }
  draw() {
    ctx.save();
    ctx.globalAlpha = 0.98;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 28, 0, Math.PI * 2);
    ctx.fillStyle = '#fff200';
    ctx.shadowColor = '#ff1744';
    ctx.shadowBlur = 32;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#000';
    ctx.stroke();
    // Draw a debug marker
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 36, 0, Math.PI * 2);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }
}
// --- End UltProjectile ---

// --- Add test bullet button to UI ---
// (Deleted: const testBulletBtn = document.createElement('button'); ... uiDiv.appendChild(testBulletBtn);)
// --- End test bullet button ---

// Load Zed sprite
const zedImg = new Image();
zedImg.src = 'zed.png';
let zedImgLoaded = false;
zedImg.onload = () => { zedImgLoaded = true; };

// Patch CaitlynAI.draw to use zed.png for Zed
const origCaitlynDraw = CaitlynAI.prototype.draw;
CaitlynAI.prototype.draw = function() {
  if (this.isZed && zedImgLoaded) {
    if (this.hp <= 0 && !this.dead) return;
    // Draw healthbar
    drawHealthbar(this.x, this.y - CAITLYN_RADIUS - 40, 44, 7, this.hp, CAITLYN_BASE_HP + this.getBonusHP());
    ctx.save();
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.attackRange, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(0,255,0,0.25)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 6]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
    if (this.dead) return;
    // Draw Zed sprite or fallback
    const SPRITE_SIZE = 64;
    let drawX = this.x - SPRITE_SIZE / 2;
    let drawY = this.y - SPRITE_SIZE / 2;
    ctx.save();
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 25;
    if (zedImgLoaded) {
      ctx.drawImage(zedImg, drawX, drawY, SPRITE_SIZE, SPRITE_SIZE);
    } else {
      // Fallback: draw green circle with 'Z'
      ctx.beginPath();
      ctx.arc(this.x, this.y, SPRITE_SIZE/2, 0, Math.PI * 2);
      ctx.fillStyle = '#00ff00';
      ctx.globalAlpha = 0.85;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.font = 'bold 36px monospace';
      ctx.fillStyle = '#222';
      ctx.textAlign = 'center';
      ctx.fillText('Z', this.x, this.y + 12);
    }
    ctx.shadowBlur = 0;
    ctx.restore();
    // Draw speech bubble/thought if needed
    if (this.thoughtTimer > 0 && this.lastThought) {
      ctx.save();
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.92;
      const bubbleY = this.y - CAITLYN_RADIUS - 70;
      const textWidth = ctx.measureText(this.lastThought).width;
      ctx.beginPath();
      ctx.ellipse(this.x, bubbleY, textWidth/2 + 16, 18, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#222';
      ctx.globalAlpha = 1;
      ctx.fillText(this.lastThought, this.x, bubbleY + 5);
      ctx.restore();
    }
    // Draw debug overlay for Zed
    ctx.save();
    ctx.fillStyle = '#ff1744';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 2;
    ctx.fillText(`HP: ${this.hp} (${Math.round(this.x)},${Math.round(this.y)})`, this.x, this.y - CAITLYN_RADIUS - 60);
    ctx.restore();
    return;
  }
  origCaitlynDraw.call(this);
};

// Patch CaitlynAI logic to treat team -1 as enemy for both teams and vice versa
const origIsEnemy = CaitlynAI.prototype.isEnemy;
CaitlynAI.prototype.isEnemy = function(other) {
  if (this.isZed || other.isZed) return this !== other;
  if (typeof origIsEnemy === 'function') return origIsEnemy.call(this, other);
  return this.team !== other.team;
};

// --- Zed Q Projectile ---
class ZedQProjectile {
  constructor(owner, x, y, angle, qLevel, bonusAD) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = 1700 * GAME_UNIT_TO_PX;
    this.range = 1600 * GAME_UNIT_TO_PX;
    this.width = 50 * GAME_UNIT_TO_PX;
    this.distanceTraveled = 0;
    this.alive = true;
    this.hitTargets = new Set();
    // Damage calculation
    const baseDmg = [80, 115, 150, 185, 220][qLevel - 1] || 80;
    this.baseDamage = baseDmg + bonusAD;
  }
  update(delta) {
    if (!this.alive) return;
    const dx = Math.cos(this.angle) * this.speed * delta;
    const dy = Math.sin(this.angle) * this.speed * delta;
    this.x += dx;
    this.y += dy;
    this.distanceTraveled += Math.hypot(dx, dy);
    if (this.distanceTraveled > this.range) this.alive = false;
    // Hit logic: pierce all, falloff after first
    let hitCount = 0;
    for (const c of caitlyns) {
      if (c === this.owner || c.hp <= 0 || this.hitTargets.has(c)) continue;
      // Thin rectangle collision
      const px = c.x - this.x;
      const py = c.y - this.y;
      const proj = px * Math.cos(this.angle) + py * Math.sin(this.angle);
      const ortho = -px * Math.sin(this.angle) + py * Math.cos(this.angle);
      if (proj > 0 && proj < 60 && Math.abs(ortho) < this.width / 2) {
        let dmg = this.baseDamage;
        if (hitCount > 0) dmg = Math.round(dmg * 0.6); // 60% after first
        c.hp -= dmg;
        this.hitTargets.add(c);
        hitCount++;
      }
    }
    // Optionally hit minions, turrets, etc. (add logic as needed)
  }
  draw() {
    if (!this.alive) return;
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.width / 2, 12, this.angle, 0, Math.PI * 2);
    ctx.fillStyle = '#00eaff';
    ctx.shadowColor = '#222';
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#0ff';
    ctx.stroke();
    // Add trailing particles
    spawnParticles(this.x, this.y, '#00eaff', 2, 60, 0.25, 'trail');
    ctx.restore();
  }
}
// --- End Zed Q Projectile ---

// Patch CaitlynAI Q logic for Zed
const origCaitlynUpdate = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // Zed Q logic
    if (this.qWindup > 0) {
      this.qWindup -= delta;
      if (this.qWindup <= 0) {
        // Fire Zed Q
        let angle = this.qAngle * Math.PI;
        // For now, use Q level 5 and bonusAD = 0 (can be improved)
        let qLevel = 5;
        let bonusAD = 0;
        projectiles.push(new ZedQProjectile(this, this.x, this.y, angle, qLevel, bonusAD));
        this.qTimer = 6; // 6s cooldown
      }
      return;
    }
    // Q cast trigger
    if (this.useQIntent > 0.5 && this.qTimer <= 0 && !this.qActive && this.qWindup <= 0) {
      this.qAttempts++;
      this.qWindup = 0.25; // Fast windup for Zed
      return;
    }
    // Continue with rest of update
    origCaitlynUpdate.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  // Default Caitlyn logic
  origCaitlynUpdate.call(this, others, delta, projectiles, minions, turrets);
};

// Patch CaitlynAI update to make Zed unkillable
const origCaitlynUpdateUnkillable = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  origCaitlynUpdateUnkillable.call(this, others, delta, projectiles, minions, turrets);
  if (this.isZed) {
    this.hp = Math.max(this.hp, 1);
    this.dead = false;
  }
};

// --- Zed Living Shadow (W) ---
class ZedShadow {
  constructor(owner, x, y) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.spawnTime = performance.now();
    this.duration = 5000; // ms
    this.active = true;
  }
  update() {
    if (!this.active) return;
    if (performance.now() - this.spawnTime > this.duration) {
      this.active = false;
    }
  }
  draw() {
    if (!this.active) return;
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 22, 0, Math.PI * 2);
    ctx.fillStyle = '#222';
    ctx.shadowColor = '#00eaff';
    ctx.shadowBlur = 18;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#00eaff';
    ctx.stroke();
    // Pulsing ring
    ctx.globalAlpha = 0.3 + 0.2 * Math.sin(performance.now() / 200);
    ctx.beginPath();
    ctx.arc(this.x, this.y, 32 + 6 * Math.sin(performance.now() / 120), 0, Math.PI * 2);
    ctx.strokeStyle = '#00eaff';
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.globalAlpha = 1;
    // Particles
    spawnParticles(this.x, this.y, '#00eaff', 1, 40, 0.18, 'sparkle');
    ctx.restore();
  }
}
// --- End Zed Living Shadow ---

// Patch CaitlynAI for Zed W logic
const origCaitlynUpdateW = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // --- Living Shadow state ---
    if (!this.zedShadow) this.zedShadow = null;
    if (!this.wCooldown) this.wCooldown = 0;
    if (!this.wActive) this.wActive = false;
    if (!this.wSwapAvailable) this.wSwapAvailable = false;
    if (!this.wTimer) this.wTimer = 0;
    // Cooldown
    if (this.wCooldown > 0) this.wCooldown -= delta;
    // Update shadow
    if (this.zedShadow && this.zedShadow.active) {
      this.zedShadow.update();
      if (!this.zedShadow.active) {
        this.zedShadow = null;
        this.wActive = false;
        this.wSwapAvailable = false;
        this.wCooldown = 20; // 20s base cooldown
      }
    }
    // --- W input logic ---
    // For demo: use E key for W cast, R key for swap (replace with real input as needed)
    if (this.useWIntent > 0.5) {
      if (!this.zedShadow && this.wCooldown <= 0) {
        let angle = this.qAngle * Math.PI;
        let dist = 1200 * GAME_UNIT_TO_PX;
        let sx = this.x + Math.cos(angle) * dist;
        let sy = this.y + Math.sin(angle) * dist;
        this.zedShadow = new ZedShadow(this, sx, sy);
        this.wActive = true;
        this.wSwapAvailable = true;
        this.wTimer = 5.0;
        this.wCooldown = 20;
      } else if (this.zedShadow && this.wSwapAvailable) {
        let dx = this.zedShadow.x - this.x;
        let dy = this.zedShadow.y - this.y;
        let dist = Math.hypot(dx, dy);
        if (dist <= 1300 * GAME_UNIT_TO_PX) {
          let tmpX = this.x, tmpY = this.y;
          this.x = this.zedShadow.x;
          this.y = this.zedShadow.y;
          this.zedShadow.x = tmpX;
          this.zedShadow.y = tmpY;
          this.zedShadow.active = false;
          this.zedShadow = null;
          this.wActive = false;
          this.wSwapAvailable = false;
        }
      }
    }
    // Shadow timer
    if (this.zedShadow && this.zedShadow.active) {
      this.wTimer -= delta;
      if (this.wTimer <= 0) {
        this.zedShadow.active = false;
        this.zedShadow = null;
        this.wActive = false;
        this.wSwapAvailable = false;
      }
    }
    // --- Shadow mimics Q ---
    if (this.qWindup > 0) {
      this.qWindup -= delta;
      if (this.qWindup <= 0) {
        // Fire Zed Q from both Zed and shadow if present
        let angle = this.qAngle * Math.PI;
        let qLevel = 5;
        let bonusAD = 0;
        projectiles.push(new ZedQProjectile(this, this.x, this.y, angle, qLevel, bonusAD));
        if (this.zedShadow && this.zedShadow.active) {
          projectiles.push(new ZedQProjectile(this, this.zedShadow.x, this.zedShadow.y, angle, qLevel, bonusAD));
        }
        this.qTimer = 6;
      }
      return;
    }
    if (this.useQIntent > 0.5 && this.qTimer <= 0 && !this.qActive && this.qWindup <= 0) {
      this.qAttempts++;
      this.qWindup = 0.25;
      return;
    }
    // Continue with rest of update
    origCaitlynUpdateW.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  origCaitlynUpdateW.call(this, others, delta, projectiles, minions, turrets);
};
// --- Draw Zed shadow in game loop ---
const origCaitlynDrawW = CaitlynAI.prototype.draw;
CaitlynAI.prototype.draw = function() {
  if (this.isZed && this.zedShadow && this.zedShadow.active) {
    this.zedShadow.draw();
  }
  origCaitlynDrawW.call(this);
};
// --- End Zed Living Shadow ---

// Patch CaitlynAI for Zed melee attack and ability restrictions
const origCaitlynUpdateAbilities = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // Set Zed's attack range to melee (125 units)
    this.attackRange = 125 * GAME_UNIT_TO_PX;
    // Prevent Caitlyn Q/W/E logic for Zed (handled in Zed-specific code)
    // Only allow Zed's Q and W logic (already patched above)
    // Skip Caitlyn's Q windup/cast, trap, and net logic
    // --- Zed Q and W logic are handled in previous patch ---
    // Continue with rest of update (movement, attack, etc.)
    origCaitlynUpdateAbilities.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  origCaitlynUpdateAbilities.call(this, others, delta, projectiles, minions, turrets);
};

const origCaitlynUpdateBlockAbilities = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // Set Zed's attack range to melee (125 units)
    this.attackRange = 125 * GAME_UNIT_TO_PX;
    // Only run Zed's Q and W logic (already patched above), and melee attack
    // Block Caitlyn's Q, W, E logic by returning early here
    // --- Zed Q and W logic are handled in previous patch ---
    // Melee attack logic (copied from Caitlyn, but no headshot, trap, or net)
    this.attackTimer -= delta;
    const { moveX, moveY, target, attack } = this.decide(others, minions, turrets);
    let doAttack = attack;
    if (!doAttack && target && this.attackTimer <= 0) {
      const dist = Math.hypot(target.x - this.x, target.y - this.y);
      if (dist <= this.attackRange) doAttack = true;
    }
    if (this.windupTimer > 0) {
      this.windupTimer -= delta;
      if (this.windupTimer <= 0 && this.pendingAttack) {
        const { target, damage } = this.pendingAttack;
        if (target && target.hp > 0) {
          basicProjectiles.push(new BasicProjectile(this.x, this.y, target.x, target.y, this.color, () => {
            target.hp -= damage;
            if (target.hp < 0) target.hp = 0;
            if (target.hp === 0 && target instanceof Minion) target.alive = false;
            this.damageDealt += damage;
          }, false, target, damage));
        }
        this.pendingAttack = null;
      }
      return;
    }
    const dist = target ? Math.hypot(target.x - this.x, target.y - this.y) : Infinity;
    if (doAttack && target && this.attackTimer <= 0 && dist <= this.attackRange) {
      this.attackAttempts++;
      let damage = CAITLYN_BASE_AD; // Use base AD for now
      this.windupTimer = this.attackWindup;
      this.pendingAttack = { target, damage };
      this.attackTimer = this.attackDelay;
      if (target && target instanceof Minion) target.lastHitBy = this;
      // --- Kiting improvement: set post-attack kite burst ---
      this.kiteBurstTimer = 0.18; // 180ms burst after attack
      if (target) {
        const dx = this.x - target.x;
        const dy = this.y - target.y;
        const len = Math.hypot(dx, dy);
        if (len > 1e-3) {
          this.kiteBurstVec = { x: dx / len, y: dy / len };
        } else {
          this.kiteBurstVec = { x: 0, y: 0 };
        }
      } else {
        this.kiteBurstVec = { x: 0, y: 0 };
      }
      return;
    } else {
      // --- Advanced kiting logic ---
      let speed = this.moveSpeed * parseFloat(speedSlider.value);
      if (this.slowTimer > 0) speed *= E_SLOW_AMOUNT;
      let moveVecX = 0, moveVecY = 0;
      let meleeThreats = minions.filter(m => m.alive && m.team !== this.team && (m.type === 'melee' || m.type === 'super') && Math.hypot(m.x - this.x, m.y - this.y) < this.attackRange * 1.1);
      // Calculate safe direction away from all melee threats
      let threatVecX = 0, threatVecY = 0;
      for (const m of meleeThreats) {
        const dx = this.x - m.x;
        const dy = this.y - m.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 1e-3) {
          threatVecX += dx / (dist * dist); // Weight by inverse square distance
          threatVecY += dy / (dist * dist);
        }
      }
      // Avoid walking into turrets
      let avoidTurretX = 0, avoidTurretY = 0;
      for (const t of turrets) {
        if (t.team !== this.team) {
          const turretDist = Math.hypot(this.x - t.x, this.y - t.y) - t.range;
          if (turretDist < 40) {
            const tx = this.x - t.x;
            const ty = this.y - t.y;
            const tlen = Math.hypot(tx, ty);
            if (tlen > 1e-3) {
              avoidTurretX += tx / tlen;
              avoidTurretY += ty / tlen;
            }
          }
        }
      }
      // Avoid minions (collision avoidance)
      let avoidMinionX = 0, avoidMinionY = 0;
      for (const m of minions) {
        if (m.alive && Math.hypot(this.x - m.x, this.y - m.y) < 32) {
          avoidMinionX += (this.x - m.x);
          avoidMinionY += (this.y - m.y);
        }
      }
      // Strafe direction alternates every second
      if (!this._strafeDir || Math.floor(performance.now() / 1000) % 2 === 0) {
        this._strafeDir = 1;
      } else {
        this._strafeDir = -1;
      }
      // Main movement logic
      if (this.attackTimer > 0 && (meleeThreats.length > 0 || (target && Math.hypot(target.x - this.x, target.y - this.y) < this.attackRange * 0.9))) {
        // Kite away from all melee threats (or target if no melee)
        if (threatVecX !== 0 || threatVecY !== 0) {
          moveVecX = threatVecX + avoidTurretX * 0.7 + avoidMinionX * 0.2;
          moveVecY = threatVecY + avoidTurretY * 0.7 + avoidMinionY * 0.2;
        } else if (target) {
          // Fallback: kite from target
          const dx = this.x - target.x;
          const dy = this.y - target.y;
          const len = Math.hypot(dx, dy);
          if (len > 1e-3) {
            moveVecX = dx / len + avoidTurretX * 0.7 + avoidMinionX * 0.2;
            moveVecY = dy / len + avoidTurretY * 0.7 + avoidMinionY * 0.2;
          }
        }
      } else if (target) {
        // In range: strafe
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const len = Math.hypot(dx, dy);
        let perpX = -dy / (len || 1);
        let perpY = dx / (len || 1);
        moveVecX = perpX * this._strafeDir + avoidTurretX * 0.7 + avoidMinionX * 0.2;
        moveVecY = perpY * this._strafeDir + avoidTurretY * 0.7 + avoidMinionY * 0.2;
        // If out of range, move toward target
        if (len > this.attackRange * 0.98) {
          moveVecX = dx / len + avoidTurretX * 0.7 + avoidMinionX * 0.2;
          moveVecY = dy / len + avoidTurretY * 0.7 + avoidMinionY * 0.2;
        }
      } else {
        // No target: wander using neural net output, but keep moving
        moveVecX = moveX + avoidTurretX * 0.7 + avoidMinionX * 0.2;
        moveVecY = moveY + avoidTurretY * 0.7 + avoidMinionY * 0.2;
      }
      // Normalize movement vector
      const mlen = Math.hypot(moveVecX, moveVecY);
      if (mlen > 1e-3) {
        moveVecX /= mlen;
        moveVecY /= mlen;
      }
      // Avoid map edges
      const edgeBuffer = 40;
      if (this.x < edgeBuffer) moveVecX += 0.5;
      if (this.x > CANVAS_WIDTH - edgeBuffer) moveVecX -= 0.5;
      if (this.y < edgeBuffer) moveVecY += 0.5;
      if (this.y > CANVAS_HEIGHT - edgeBuffer) moveVecY -= 0.5;
      // Reduce random jitter for more purposeful movement
      const jitter = 0.01;
      let newX = this.x + (moveVecX + (Math.random() - 0.5) * jitter) * speed * delta;
      let newY = this.y + (moveVecY + (Math.random() - 0.5) * jitter) * speed * delta;
      if (!isBlockedMap(newX, newY)) { this.x = newX; this.y = newY; }
      // Clamp
      if (!isFinite(this.x) || !isFinite(this.y)) {
        this.x = Math.max(0, Math.min(CANVAS_WIDTH, isFinite(this.x) ? this.x : 400));
        this.y = Math.max(0, Math.min(CANVAS_HEIGHT, isFinite(this.y) ? this.y : 300));
      } else {
        this.x = Math.max(0, Math.min(CANVAS_WIDTH, this.x));
        this.y = Math.max(0, Math.min(CANVAS_HEIGHT, this.y));
      }
    }
    // Block Caitlyn's Q/W/E logic for Zed
    return;
  }
  origCaitlynUpdateBlockAbilities.call(this, others, delta, projectiles, minions, turrets);
};

// --- Zed Shadow Slash (E) ---
class ZedESlash {
  constructor(owner, x, y, eLevel, bonusAD, isShadow) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.radius = 500 * GAME_UNIT_TO_PX;
    this.eLevel = eLevel;
    this.bonusAD = bonusAD;
    this.isShadow = isShadow;
    this.hit = new Set();
    this.visualTimer = 0.25; // Show for 0.25s
  }
  update(delta) {
    this.visualTimer -= delta;
    if (this.visualTimer <= 0) this.alive = false;
    // Damage logic only on first frame
    if (!this.didDamage) {
      this.didDamage = true;
      let baseDmg = [70, 95, 120, 145, 170][this.eLevel - 1] || 70;
      let dmg = baseDmg + Math.round(this.bonusAD * 0.8);
      let slowPct = [0.2, 0.25, 0.3, 0.35, 0.4][this.eLevel - 1] || 0.2;
      let slowDuration = 1.5;
      for (const c of caitlyns) {
        if (c.hp <= 0 || this.hit.has(c)) continue;
        const dist = Math.hypot(c.x - this.x, c.y - this.y);
        if (dist <= this.radius) {
          // Only first hit per cast deals damage
          if (!c._zedEHitThisCast) {
            c.hp -= dmg;
            c._zedEHitThisCast = true;
            if (this.isShadow) {
              // Apply slow
              c._zedESlow = slowPct;
              c._zedESlowTimer = slowDuration;
              // Cooldown refund logic (handled in Zed's update)
              if (!c._zedERefunded && c !== this.owner) {
                c._zedERefunded = true;
                if (this.owner && this.owner._zedEChampHit) this.owner._zedEChampHit.add(c);
              }
            }
          } else if (this.isShadow) {
            // Refresh slow if hit by shadow after main
            c._zedESlow = slowPct;
            c._zedESlowTimer = slowDuration;
          }
          this.hit.add(c);
        }
      }
    }
  }
  draw() {
    if (this.visualTimer <= 0) return;
    ctx.save();
    ctx.globalAlpha = 0.22 + 0.18 * Math.sin(performance.now() / 80);
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = this.isShadow ? '#00eaff' : '#ffeb3b';
    ctx.shadowColor = this.isShadow ? '#00eaff' : '#ffeb3b';
    ctx.shadowBlur = 24;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}
// --- End Zed Shadow Slash ---

// Patch CaitlynAI for Zed E logic
const origCaitlynUpdateE = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // --- Zed E state ---
    if (!this.eCooldown) this.eCooldown = 0;
    if (!this.energy) this.energy = 200;
    if (!this._zedEChampHit) this._zedEChampHit = new Set();
    // Cooldown
    if (this.eCooldown > 0) this.eCooldown -= delta;
    // Slow effect
    if (this._zedESlowTimer > 0) {
      this._zedESlowTimer -= delta;
      if (this._zedESlowTimer <= 0) this._zedESlow = 0;
    }
    // --- E input logic ---
    if (this.useEIntent > 0.5) {
      if (this.eCooldown <= 0 && this.energy >= 50) {
        let eLevel = 5;
        let bonusAD = 0;
        for (const c of caitlyns) c._zedEHitThisCast = false; c._zedERefunded = false;
        this._zedEChampHit.clear();
        let eSlash = new ZedESlash(this, this.x, this.y, eLevel, bonusAD, false);
        eSlash.alive = true;
        projectiles.push(eSlash);
        if (this.zedShadow && this.zedShadow.active) {
          let shadowSlash = new ZedESlash(this, this.zedShadow.x, this.zedShadow.y, eLevel, bonusAD, true);
          shadowSlash.alive = true;
          projectiles.push(shadowSlash);
        }
        if (this._zedEChampHit.size > 0) {
          this.eCooldown = Math.max(0, 5 - 2 * this._zedEChampHit.size);
        } else {
          this.eCooldown = 5;
        }
        this.energy -= 50;
      }
    }
    // Update all E slashes (visuals, slow)
    for (const p of projectiles) {
      if (p instanceof ZedESlash && p.owner === this) p.update(delta);
    }
    // Continue with rest of update
    origCaitlynUpdateE.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  origCaitlynUpdateE.call(this, others, delta, projectiles, minions, turrets);
};
// --- End Zed Shadow Slash ---

// --- Zed Death Mark (R) ---
class ZedRShadow {
  constructor(owner, x, y) {
    this.owner = owner;
    this.x = x;
    this.y = y;
    this.spawnTime = performance.now();
    this.duration = 6000; // ms
    this.active = true;
  }
  update() {
    if (!this.active) return;
    if (performance.now() - this.spawnTime > this.duration) {
      this.active = false;
    }
  }
  draw() {
    if (!this.active) return;
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 24, 0, Math.PI * 2);
    ctx.fillStyle = '#222';
    ctx.shadowColor = '#ff1744';
    ctx.shadowBlur = 22;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#ff1744';
    ctx.stroke();
    // Red pulse
    ctx.globalAlpha = 0.4 + 0.3 * Math.sin(performance.now() / 120);
    ctx.beginPath();
    ctx.arc(this.x, this.y, 34 + 8 * Math.sin(performance.now() / 80), 0, Math.PI * 2);
    ctx.strokeStyle = '#ff1744';
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.globalAlpha = 1;
    // Particles
    spawnParticles(this.x, this.y, '#ff1744', 2, 60, 0.18, 'sparkle');
    ctx.restore();
  }
}
// --- End Zed Death Mark ---

// Patch CaitlynAI for Zed R logic
const origCaitlynUpdateR = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // --- Zed R state ---
    if (!this.rCooldown) this.rCooldown = 0;
    if (!this.rLevel) this.rLevel = 3;
    if (!this.rShadow) this.rShadow = null;
    if (!this.rMarkActive) this.rMarkActive = false;
    if (!this.rMarkTarget) this.rMarkTarget = null;
    if (!this.rMarkTimer) this.rMarkTimer = 0;
    if (!this.rMarkBaseDmg) this.rMarkBaseDmg = 0;
    if (!this.rMarkDamage) this.rMarkDamage = 0;
    if (!this.rUntargetable) this.rUntargetable = false;
    if (!this.rUntargetableTimer) this.rUntargetableTimer = 0;
    // Cooldown
    if (this.rCooldown > 0) this.rCooldown -= delta;
    // Update R shadow
    if (this.rShadow && this.rShadow.active) this.rShadow.update();
    // --- R input logic ---
    if (this.useRIntent > 0.5) {
      if (!this.rMarkActive && this.rCooldown <= 0) {
        let candidates = caitlyns.filter(c => c !== this && c.hp > 0 && c.team !== this.team);
        if (candidates.length > 0) {
          let target = candidates.reduce((best, c) => Math.hypot(c.x - this.x, c.y - this.y) < Math.hypot(best.x - this.x, best.y - this.y) ? c : best, candidates[0]);
          let dx = target.x - this.x;
          let dy = target.y - this.y;
          let dist = Math.hypot(dx, dy);
          let dashDist = Math.min(dist, 1200 * GAME_UNIT_TO_PX);
          let dashAngle = Math.atan2(dy, dx);
          this.rShadow = new ZedRShadow(this, this.x, this.y);
          this.rUntargetable = true;
          this.rUntargetableTimer = 0.75;
          this.rMarkTarget = target;
          this.rMarkActive = true;
          this.rMarkTimer = 3.0;
          this.rMarkBaseDmg = [100, 200, 300][this.rLevel - 1] || 100;
          this.rMarkDamage = 0;
          setTimeout(() => {
            this.x = target.x - Math.cos(dashAngle) * 40;
            this.y = target.y - Math.sin(dashAngle) * 40;
            this.rUntargetable = false;
          }, 750);
          this.rCooldown = [120, 100, 80][this.rLevel - 1] || 120;
        }
      } else if (this.rShadow && this.rShadow.active) {
        let tmpX = this.x, tmpY = this.y;
        this.x = this.rShadow.x;
        this.y = this.rShadow.y;
        this.rShadow.active = false;
        this.rShadow = null;
      }
    }
    // Untargetable timer
    if (this.rUntargetable) {
      this.rUntargetableTimer -= delta;
      if (this.rUntargetableTimer <= 0) this.rUntargetable = false;
    }
    // Mark logic: track damage
    if (this.rMarkActive && this.rMarkTarget && this.rMarkTarget.hp > 0) {
      this.rMarkTimer -= delta;
      // Track damage dealt to target
      if (!this.rMarkTarget._zedRMarkLastHP) this.rMarkTarget._zedRMarkLastHP = this.rMarkTarget.hp;
      let deltaDmg = this.rMarkTarget._zedRMarkLastHP - this.rMarkTarget.hp;
      if (deltaDmg > 0) this.rMarkDamage += deltaDmg;
      this.rMarkTarget._zedRMarkLastHP = this.rMarkTarget.hp;
      // Visual indicator
      this.rMarkTarget._zedRMarked = true;
      this.rMarkTarget._zedRMarkTimer = this.rMarkTimer;
      if (this.rMarkTimer <= 0) {
        // Detonate
        let totalDmg = this.rMarkBaseDmg + Math.round(this.rMarkDamage * 0.65);
        this.rMarkTarget.hp -= totalDmg;
        this.rMarkTarget._zedRMarked = false;
        this.rMarkTarget._zedRMarkTimer = 0;
        this.rMarkActive = false;
        this.rMarkTarget = null;
        this.rMarkDamage = 0;
      }
    }
    // Draw R shadow
    if (this.rShadow && this.rShadow.active) this.rShadow.draw();
    // Marked target visual
    for (const c of caitlyns) {
      if (c._zedRMarked && c._zedRMarkTimer > 0) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(c.x, c.y, CAITLYN_RADIUS + 32, 0, Math.PI * 2);
        ctx.strokeStyle = '#ff1744';
        ctx.lineWidth = 5;
        ctx.setLineDash([10, 8]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = 'bold 18px monospace';
        ctx.fillStyle = '#ff1744';
        ctx.fillText('â˜ ', c.x, c.y - CAITLYN_RADIUS - 38);
        ctx.restore();
      }
    }
    // Continue with rest of update
    origCaitlynUpdateR.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  origCaitlynUpdateR.call(this, others, delta, projectiles, minions, turrets);
};
// --- End Zed Death Mark ---

const origCaitlynUpdateUnkillableAbsolute = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  origCaitlynUpdateUnkillableAbsolute.call(this, others, delta, projectiles, minions, turrets);
  if (this.isZed) {
    this.hp = Math.max(this.hp, 1);
    this.dead = false;
  }
};

// --- Zed Brain Persistence ---
const ZED_BRAIN_KEY = 'zed_brain';
let savedZedBrain = null;
function loadZedBrain() {
  try {
    const data = localStorage.getItem(ZED_BRAIN_KEY);
    if (data) {
      let loaded = JSON.parse(data);
      loaded = migrateBrain(loaded);
      savedZedBrain = loaded;
      console.log('Loaded saved Zed brain from localStorage:', savedZedBrain);
    }
  } catch (e) {
    console.log('No saved Zed brain found, starting fresh.');
  }
}
function saveZedBrain(brain) {
  localStorage.setItem(ZED_BRAIN_KEY, JSON.stringify(migrateBrain(brain)));
}
// --- End Zed Brain Persistence ---

// Patch initCaitlyns to use Zed's brain
const origInitCaitlyns = initCaitlyns;
initCaitlyns = function(brain) {
  loadZedBrain();
  origInitCaitlyns(brain);
  // Assign Zed's brain
  for (const c of caitlyns) {
    if (c.isZed) {
      if (savedZedBrain) c.brain = savedZedBrain.slice();
      else c.brain = CaitlynAI.randomBrain();
    }
  }
};
// --- End patch ---

// Patch Zed's update to use brain for ability and attack decisions
const origCaitlynUpdateZedBrain = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // Zed is absolutely unkillable
    this.hp = Math.max(this.hp, 1);
    this.dead = false;
    // Zed brain: 35 inputs, 11 outputs (same as Caitlyn)
    // Inputs: positions, HP, cooldowns, etc. (reuse Caitlyn's logic)
    let inputs = [];
    let me = this;
    const myBush = whichBush(this.x, this.y);
    let enemies = caitlyns.filter(c => c.team !== this.team && c.hp > 0 && (myBush === -1 || whichBush(c.x, c.y) === myBush || whichBush(c.x, c.y) === -1));
    let allies = caitlyns.filter(c => c.team === this.team && c !== this && c.hp > 0);
    for (let i = 0; i < TEAM_SIZE; ++i) {
      let e = enemies[i] || { x: 0, y: 0, hp: 0 };
      inputs.push((e.x - me.x) / CANVAS_WIDTH, (e.y - me.y) / CANVAS_HEIGHT, e.hp / 600);
    }
    for (let i = 0; i < TEAM_SIZE - 1; ++i) {
      let a = allies[i] || { x: 0, y: 0, hp: 0 };
      inputs.push((a.x - me.x) / CANVAS_WIDTH, (a.y - me.y) / CANVAS_HEIGHT, a.hp / 600);
    }
    inputs.push(this.attackTimer / 2, this.qTimer / 10, 0, inBrush(this.x, this.y) ? 1 : 0);
    inputs.push(distToNearestBush(this.x, this.y) / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT));
    let minTurretDist = 1e9;
    for (const t of turrets) {
      if (t.team !== this.team) {
        const d = Math.hypot(this.x - t.x, this.y - t.y) - t.range;
        if (Math.abs(d) < Math.abs(minTurretDist)) minTurretDist = d;
      }
    }
    inputs.push(Math.max(-1, Math.min(1, minTurretDist / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT))));
    while (inputs.length < 18) inputs.push(0);
    let allTraps = [];
    caitlyns.forEach(c => allTraps.push(...c.traps));
    allTraps = allTraps.filter(trap => trap.alive);
    allTraps.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    for (let i = 0; i < 3; ++i) {
      const trap = allTraps[i];
      if (trap) {
        inputs.push((trap.x - me.x) / CANVAS_WIDTH);
        inputs.push((trap.y - me.y) / CANVAS_HEIGHT);
        inputs.push(trap.armed ? 1 : 0);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    inputs.push(this.eCooldown / 16);
    let nearestEnemyDist = 1e9;
    for (const enemy of enemies) {
      const dist = Math.hypot(enemy.x - me.x, enemy.y - me.y);
      if (dist < nearestEnemyDist) nearestEnemyDist = dist;
    }
    inputs.push(Math.min(1, nearestEnemyDist / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT)));
    let friendlyMinions = minions.filter(m => m.team === this.team && m.alive);
    let enemyMinions = minions.filter(m => m.team !== this.team && m.alive);
    friendlyMinions.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    enemyMinions.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    for (let i = 0; i < 3; ++i) {
      const minion = friendlyMinions[i];
      if (minion) {
        inputs.push((minion.x - me.x) / CANVAS_WIDTH);
        inputs.push((minion.y - me.y) / CANVAS_HEIGHT);
        inputs.push(minion.hp / minion.baseHp);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    for (let i = 0; i < 3; ++i) {
      const minion = enemyMinions[i];
      if (minion) {
        inputs.push((minion.x - me.x) / CANVAS_WIDTH);
        inputs.push((minion.y - me.y) / CANVAS_HEIGHT);
        inputs.push(minion.hp / minion.baseHp);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    let out = feedforward(inputs, this.brain);
    // Outputs: moveX, moveY, attack, useQ, useW, useE, useR, qAngle, rTarget
    const [moveX, moveY, attack, useQ, useW, useE, useR, qAngle, rTarget] = out;
    this.moveX = moveX;
    this.moveY = moveY;
    this.attackIntent = attack;
    this.useQIntent = useQ;
    this.useWIntent = useW;
    this.useEIntent = useE;
    this.useRIntent = useR;
    this.qAngle = qAngle;
    this.rTarget = rTarget;
    // Now abilities will be triggered by these intents in the rest of the update logic
    origCaitlynUpdateZedBrain.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  origCaitlynUpdateZedBrain.call(this, others, delta, projectiles, minions, turrets);
};
// --- End Zed brain patch ---

// Patch save logic to save best Zed brain after each generation
const origMain = main;
main = function() {
  loadBrain();
  loadZedBrain();
  origMain();
};
// Save best Zed brain after each generation
const origInitCaitlynsPatched = initCaitlyns;
initCaitlyns = function(brain) {
  origInitCaitlynsPatched(brain);
  // Save best Zed brain
  let bestZed = caitlyns.find(c => c.isZed);
  if (bestZed) saveZedBrain(bestZed.brain);
};
// ... existing code ...

// Patch TurretProjectile to animate as a red laser
const origTurretProjectileDraw = TurretProjectile.prototype.draw;
TurretProjectile.prototype.draw = function() {
  if (!this.alive || !this.target || this.target.hp <= 0) return;
  ctx.save();
  // Draw thin red laser beam from turret to target
  ctx.globalAlpha = 0.85;
  ctx.strokeStyle = '#ff1744';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(this.x, this.y);
  ctx.lineTo(this.target.x, this.target.y);
  ctx.shadowColor = '#ff1744';
  ctx.shadowBlur = 10;
  ctx.stroke();
  ctx.shadowBlur = 0;
  // Draw thick red impact circle at target
  ctx.beginPath();
  ctx.arc(this.target.x, this.target.y, 16, 0, Math.PI * 2);
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = '#ff1744';
  ctx.shadowColor = '#ff1744';
  ctx.shadowBlur = 18;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1;
  ctx.lineWidth = 3.5;
  ctx.strokeStyle = '#fff';
  ctx.stroke();
  ctx.restore();
};
// ... existing code ...

// --- Zed Ability Visual Cues ---
const origZedDraw = CaitlynAI.prototype.draw;
CaitlynAI.prototype.draw = function() {
  if (this.isZed && zedImgLoaded) {
    // Q windup: blue glow
    if (this.qWindup > 0) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 38, 0, Math.PI * 2);
      ctx.fillStyle = '#00eaff';
      ctx.shadowColor = '#00eaff';
      ctx.shadowBlur = 18;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    // W cast: dark arc from Zed to shadow
    if (this.zedShadow && this.zedShadow.active && this.wActive && this.wTimer > 4.8) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.zedShadow.x, this.zedShadow.y);
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 8;
      ctx.shadowColor = '#00eaff';
      ctx.shadowBlur = 12;
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    // E cast: red flash/spin
    if (this.useEIntent > 0.5 && this.eCooldown < 0.2) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 32, 0, Math.PI * 2);
      ctx.fillStyle = '#ff1744';
      ctx.shadowColor = '#ff1744';
      ctx.shadowBlur = 16;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    // R dash: fade out/in and shadow trail
    if (this.rUntargetable) {
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 34, 0, Math.PI * 2);
      ctx.fillStyle = '#ff1744';
      ctx.shadowColor = '#ff1744';
      ctx.shadowBlur = 24;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    // Draw Zed sprite as usual
    ctx.save();
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 25;
    const SPRITE_SIZE = 64;
    let drawX = this.x - SPRITE_SIZE / 2;
    let drawY = this.y - SPRITE_SIZE / 2;
    ctx.drawImage(zedImg, drawX, drawY, SPRITE_SIZE, SPRITE_SIZE);
    ctx.shadowBlur = 0;
    ctx.restore();
    // Draw shadow(s)
    if (this.zedShadow && this.zedShadow.active) this.zedShadow.draw();
    if (this.rShadow && this.rShadow.active) this.rShadow.draw();
    // Draw speech bubble/thought if needed
    if (this.thoughtTimer > 0 && this.lastThought) {
      ctx.save();
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.globalAlpha = 0.92;
      const bubbleY = this.y - CAITLYN_RADIUS - 70;
      const textWidth = ctx.measureText(this.lastThought).width;
      ctx.beginPath();
      ctx.ellipse(this.x, bubbleY, textWidth/2 + 16, 18, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 6;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#222';
      ctx.globalAlpha = 1;
      ctx.fillText(this.lastThought, this.x, bubbleY + 5);
      ctx.restore();
    }
    return;
  }
  origZedDraw.call(this);
};
// --- End Zed Ability Visual Cues ---

const origCaitlynUpdateZedBrainRandom = CaitlynAI.prototype.update;
CaitlynAI.prototype.update = function(others, delta, projectiles, minions, turrets) {
  if (this.isZed) {
    // Zed is absolutely unkillable
    this.hp = Math.max(this.hp, 1);
    this.dead = false;
    // Use neural net for movement/attack/intent as before
    let inputs = [];
    let me = this;
    const myBush = whichBush(this.x, this.y);
    let enemies = caitlyns.filter(c => c.team !== this.team && c.hp > 0 && (myBush === -1 || whichBush(c.x, c.y) === myBush || whichBush(c.x, c.y) === -1));
    let allies = caitlyns.filter(c => c.team === this.team && c !== this && c.hp > 0);
    for (let i = 0; i < TEAM_SIZE; ++i) {
      let e = enemies[i] || { x: 0, y: 0, hp: 0 };
      inputs.push((e.x - me.x) / CANVAS_WIDTH, (e.y - me.y) / CANVAS_HEIGHT, e.hp / 600);
    }
    for (let i = 0; i < TEAM_SIZE - 1; ++i) {
      let a = allies[i] || { x: 0, y: 0, hp: 0 };
      inputs.push((a.x - me.x) / CANVAS_WIDTH, (a.y - me.y) / CANVAS_HEIGHT, a.hp / 600);
    }
    inputs.push(this.attackTimer / 2, this.qTimer / 10, 0, inBrush(this.x, this.y) ? 1 : 0);
    inputs.push(distToNearestBush(this.x, this.y) / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT));
    let minTurretDist = 1e9;
    for (const t of turrets) {
      if (t.team !== this.team) {
        const d = Math.hypot(this.x - t.x, this.y - t.y) - t.range;
        if (Math.abs(d) < Math.abs(minTurretDist)) minTurretDist = d;
      }
    }
    inputs.push(Math.max(-1, Math.min(1, minTurretDist / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT))));
    while (inputs.length < 18) inputs.push(0);
    let allTraps = [];
    caitlyns.forEach(c => allTraps.push(...c.traps));
    allTraps = allTraps.filter(trap => trap.alive);
    allTraps.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    for (let i = 0; i < 3; ++i) {
      const trap = allTraps[i];
      if (trap) {
        inputs.push((trap.x - me.x) / CANVAS_WIDTH);
        inputs.push((trap.y - me.y) / CANVAS_HEIGHT);
        inputs.push(trap.armed ? 1 : 0);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    inputs.push(this.eCooldown / 16);
    let nearestEnemyDist = 1e9;
    for (const enemy of enemies) {
      const dist = Math.hypot(enemy.x - me.x, enemy.y - me.y);
      if (dist < nearestEnemyDist) nearestEnemyDist = dist;
    }
    inputs.push(Math.min(1, nearestEnemyDist / Math.max(CANVAS_WIDTH, CANVAS_HEIGHT)));
    let friendlyMinions = minions.filter(m => m.team === this.team && m.alive);
    let enemyMinions = minions.filter(m => m.team !== this.team && m.alive);
    friendlyMinions.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    enemyMinions.sort((a, b) => Math.hypot(a.x - me.x, a.y - me.y) - Math.hypot(b.x - me.x, b.y - me.y));
    for (let i = 0; i < 3; ++i) {
      const minion = friendlyMinions[i];
      if (minion) {
        inputs.push((minion.x - me.x) / CANVAS_WIDTH);
        inputs.push((minion.y - me.y) / CANVAS_HEIGHT);
        inputs.push(minion.hp / minion.baseHp);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    for (let i = 0; i < 3; ++i) {
      const minion = enemyMinions[i];
      if (minion) {
        inputs.push((minion.x - me.x) / CANVAS_WIDTH);
        inputs.push((minion.y - me.y) / CANVAS_HEIGHT);
        inputs.push(minion.hp / minion.baseHp);
      } else {
        inputs.push(0, 0, 0);
      }
    }
    let out = feedforward(inputs, this.brain);
    // Outputs: moveX, moveY, attack, useQ, useW, useE, useR, qAngle, rTarget
    const [moveX, moveY, attack, useQ, useW, useE, useR, qAngle, rTarget] = out;
    this.moveX = moveX;
    this.moveY = moveY;
    this.attackIntent = attack;
    this.useQIntent = useQ;
    this.useWIntent = useW;
    this.useEIntent = useE;
    this.useRIntent = useR;
    this.qAngle = qAngle;
    this.rTarget = rTarget;
    // --- Random ability casting for testing ---
    if (Math.random() < 0.01) this.useQIntent = 1;
    if (Math.random() < 0.008) this.useWIntent = 1;
    if (Math.random() < 0.012) this.useEIntent = 1;
    if (Math.random() < 0.006) this.useRIntent = 1;
    // --- End random casting ---
    origCaitlynUpdateZedBrainRandom.call(this, others, delta, projectiles, minions, turrets);
    return;
  }
  origCaitlynUpdateZedBrainRandom.call(this, others, delta, projectiles, minions, turrets);
};

// --- Force Zed to cast all abilities on cooldown (for debugging/visualization) ---
if (this.isZed) {
  // Q: Fire as soon as off cooldown
  if (this.qTimer <= 0 && !this.qActive && this.qWindup <= 0) {
    this.qAttempts++;
    this.qWindup = 0.25;
  }
  // W: Cast shadow as soon as off cooldown, swap if available
  if (!this.zedShadow && this.wCooldown <= 0) {
    let angle = this.qAngle * Math.PI;
    let dist = 1200 * GAME_UNIT_TO_PX;
    let sx = this.x + Math.cos(angle) * dist;
    let sy = this.y + Math.sin(angle) * dist;
    this.zedShadow = new ZedShadow(this, sx, sy);
    this.wActive = true;
    this.wSwapAvailable = true;
    this.wTimer = 5.0;
    this.wCooldown = 20;
  } else if (this.zedShadow && this.wSwapAvailable) {
    let dx = this.zedShadow.x - this.x;
    let dy = this.zedShadow.y - this.y;
    let dist = Math.hypot(dx, dy);
    if (dist <= 1300 * GAME_UNIT_TO_PX) {
      let tmpX = this.x, tmpY = this.y;
      this.x = this.zedShadow.x;
      this.y = this.zedShadow.y;
      this.zedShadow.x = tmpX;
      this.zedShadow.y = tmpY;
      this.zedShadow.active = false;
      this.zedShadow = null;
      this.wActive = false;
      this.wSwapAvailable = false;
    }
  }
  // E: Cast as soon as off cooldown and enough energy
  if (this.eCooldown <= 0 && this.energy >= 50) {
    let eLevel = 5;
    let bonusAD = 0;
    for (const c of caitlyns) c._zedEHitThisCast = false; c._zedERefunded = false;
    this._zedEChampHit.clear();
    let eSlash = new ZedESlash(this, this.x, this.y, eLevel, bonusAD, false);
    eSlash.alive = true;
    projectiles.push(eSlash);
    if (this.zedShadow && this.zedShadow.active) {
      let shadowSlash = new ZedESlash(this, this.zedShadow.x, this.zedShadow.y, eLevel, bonusAD, true);
      shadowSlash.alive = true;
      projectiles.push(shadowSlash);
    }
    if (this._zedEChampHit.size > 0) {
      this.eCooldown = Math.max(0, 5 - 2 * this._zedEChampHit.size);
    } else {
      this.eCooldown = 5;
    }
    this.energy -= 50;
  }
  // R: Cast as soon as off cooldown and not already active
  if (!this.rMarkActive && this.rCooldown <= 0) {
    let candidates = caitlyns.filter(c => c !== this && c.hp > 0 && c.team !== this.team);
    if (candidates.length > 0) {
      let target = candidates.reduce((best, c) => Math.hypot(c.x - this.x, c.y - this.y) < Math.hypot(best.x - this.x, best.y - this.y) ? c : best, candidates[0]);
      let dx = target.x - this.x;
      let dy = target.y - this.y;
      let dist = Math.hypot(dx, dy);
      let dashDist = Math.min(dist, 1200 * GAME_UNIT_TO_PX);
      let dashAngle = Math.atan2(dy, dx);
      this.rShadow = new ZedRShadow(this, this.x, this.y);
      this.rUntargetable = true;
      this.rUntargetableTimer = 0.75;
      this.rMarkTarget = target;
      this.rMarkActive = true;
      this.rMarkTimer = 3.0;
      this.rMarkBaseDmg = [100, 200, 300][this.rLevel - 1] || 100;
      this.rMarkDamage = 0;
      setTimeout(() => {
        this.x = target.x - Math.cos(dashAngle) * 40;
        this.y = target.y - Math.sin(dashAngle) * 40;
        this.rUntargetable = false;
      }, 750);
      this.rCooldown = [120, 100, 80][this.rLevel - 1] || 120;
    }
  }
}
// ... existing code ...

// After document.getElementById('ui') is available, add:
const showGoldBtn = document.createElement('button');
showGoldBtn.textContent = 'Show Gold';
showGoldBtn.style.marginTop = '8px';
showGoldBtn.onclick = () => {
  window.showPlayerGold = !window.showPlayerGold;
  showGoldBtn.textContent = window.showPlayerGold ? 'Hide Gold' : 'Show Gold';
};
document.getElementById('ui').appendChild(showGoldBtn);
window.showPlayerGold = false;

// Ensure this is at the top-level, not inside any function:
const TEMPORAL_FRAMES = 8;

// --- Add Edit Mode Button to UI ---
const editModeBtn = document.createElement('button');
editModeBtn.textContent = 'Edit Mode: OFF';
editModeBtn.style.marginTop = '8px';
let editMode = false;
editModeBtn.onclick = () => {
  editMode = !editMode;
  editModeBtn.textContent = editMode ? 'Edit Mode: ON' : 'Edit Mode: OFF';
};
document.getElementById('ui').appendChild(editModeBtn);

// --- Turret Drag Logic ---
let draggingTurret = null;
let dragOffsetX = 0, dragOffsetY = 0;
canvas.addEventListener('mousedown', e => {
  if (!editMode) return;
  const rect = canvas.getBoundingClientRect();
  const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
  for (const t of turrets) {
    if (Math.hypot(mouseX - t.x, mouseY - t.y) < 32) {
      draggingTurret = t;
      dragOffsetX = mouseX - t.x;
      dragOffsetY = mouseY - t.y;
      break;
    }
  }
});
canvas.addEventListener('mousemove', e => {
  if (!editMode || !draggingTurret) return;
  const rect = canvas.getBoundingClientRect();
  const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
  draggingTurret.x = Math.max(0, Math.min(CANVAS_WIDTH, mouseX - dragOffsetX));
  draggingTurret.y = Math.max(0, Math.min(CANVAS_HEIGHT, mouseY - dragOffsetY));
});
canvas.addEventListener('mouseup', e => {
  if (!editMode || !draggingTurret) return;
  draggingTurret = null;
  // Save turret positions to localStorage by team and index
  const turretData = {};
  let teamCounts = [0, 0];
  for (const t of turrets) {
    const idx = teamCounts[t.team]++;
    turretData[`${t.team}-${idx}`] = { x: t.x, y: t.y };
  }
  localStorage.setItem('turretPositions', JSON.stringify(turretData));
});
canvas.addEventListener('mouseleave', e => {
  if (!editMode || !draggingTurret) return;
  draggingTurret = null;
});

// --- Load turret positions from localStorage if available ---
function loadTurretPositions() {
  const data = localStorage.getItem('turretPositions');
  if (!data) return;
  try {
    const turretData = JSON.parse(data);
    if (turretData && typeof turretData === 'object') {
      let teamCounts = [0, 0];
      for (const t of turrets) {
        const idx = teamCounts[t.team]++;
        const key = `${t.team}-${idx}`;
        if (turretData[key]) {
          t.x = turretData[key].x;
          t.y = turretData[key].y;
        }
      }
    }
  } catch (e) { console.error('Failed to load turret positions:', e); }
}
// ... existing code ...

// --- Global debug log string ---
window._debugLog = '';
function appendDebugLog(msg) {
  window._debugLog += msg + '\n';
}
// ... existing code ...
// Add Download Debug Log button to UI
const downloadLogBtn = document.createElement('button');
downloadLogBtn.textContent = 'Download Debug Log';
downloadLogBtn.style.marginTop = '8px';
downloadLogBtn.onclick = () => {
  const blob = new Blob([window._debugLog], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'debug_log.txt';
  document.body.appendChild(a);
  a.click();
  setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
};
document.getElementById('ui').appendChild(downloadLogBtn);
// ... existing code ...
// In the code that logs storing generationCaitlyns:
console.log('Storing generationCaitlyns:', genCaitlyns.map(team => team.map(c => c.fitness)));
appendDebugLog('Storing generationCaitlyns: ' + JSON.stringify(genCaitlyns.map(team => team.map(c => c.fitness))));
// ... existing code ...
// In the code that logs graphing avgFitness:
console.log('Graphing avgFitness for gen', i, 'team', t, ':', m.avgFitness[t]);
appendDebugLog('Graphing avgFitness for gen ' + i + ' team ' + t + ': ' + m.avgFitness[t]);
// ... existing code ...

// --- Improved Map collision polygons (walls and river) ---
// Shrink and reposition to avoid spawn overlap and better match Wild Rift
const MAP_WALLS = [
  // Bottom left wall (smaller, away from Nexus)
  [
    {x: 0, y: CANVAS_HEIGHT * 0.93},
    {x: CANVAS_WIDTH * 0.10, y: CANVAS_HEIGHT * 0.93},
    {x: CANVAS_WIDTH * 0.10, y: CANVAS_HEIGHT},
    {x: 0, y: CANVAS_HEIGHT}
  ],
  // Top right wall (smaller, away from Nexus)
  [
    {x: CANVAS_WIDTH * 0.90, y: 0},
    {x: CANVAS_WIDTH, y: 0},
    {x: CANVAS_WIDTH, y: CANVAS_HEIGHT * 0.07},
    {x: CANVAS_WIDTH * 0.90, y: CANVAS_HEIGHT * 0.07}
  ]
];
const MAP_RIVER = [
  {x: 0, y: CANVAS_HEIGHT * 0.7},
  {x: CANVAS_WIDTH * 0.3, y: CANVAS_HEIGHT},
  {x: CANVAS_WIDTH, y: CANVAS_HEIGHT * 0.3},
  {x: CANVAS_WIDTH * 0.7, y: 0}
];

// --- Debug overlay for blocked areas ---
let showBlockedOverlay = false;
const toggleBlockedBtn = document.createElement('button');
toggleBlockedBtn.textContent = 'Show Blocked Areas';
toggleBlockedBtn.style.marginTop = '8px';
toggleBlockedBtn.onclick = () => {
  showBlockedOverlay = !showBlockedOverlay;
  toggleBlockedBtn.textContent = showBlockedOverlay ? 'Hide Blocked Areas' : 'Show Blocked Areas';
};
document.getElementById('ui').appendChild(toggleBlockedBtn);

function drawBlockedOverlay(ctx) {
  ctx.save();
  // Walls
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#ff1744';
  for (const wall of MAP_WALLS) {
    ctx.beginPath();
    ctx.moveTo(wall[0].x, wall[0].y);
    for (let i = 1; i < wall.length; ++i) ctx.lineTo(wall[i].x, wall[i].y);
    ctx.closePath();
    ctx.fill();
  }
  // River (optional: blue overlay)
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = '#42a5f5';
  ctx.beginPath();
  ctx.moveTo(MAP_RIVER[0].x, MAP_RIVER[0].y);
  for (let i = 1; i < MAP_RIVER.length; ++i) ctx.lineTo(MAP_RIVER[i].x, MAP_RIVER[i].y);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();
}
// ... existing code ...
// In the main game rendering loop, after drawMapOverlay(ctx):
if (showBlockedOverlay) drawBlockedOverlay(ctx);
// ... existing code ...

function pointInPolygon(x, y, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi + 1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function isBlockedMap(x, y) {
  // Check walls
  for (const wall of MAP_WALLS) if (pointInPolygon(x, y, wall)) return true;
  // Check river (optional: make river impassable, or just slow)
  // Uncomment next line to make river impassable:
  // if (pointInPolygon(x, y, MAP_RIVER)) return true;
  return false;
}
// ... existing code ...
// --- Patch unit movement to block entry into walls/river ---
// In CaitlynAI.update and Minion.update, after calculating new x/y:
// Instead of directly setting this.x/this.y, check isBlockedMap(newX, newY)
// If blocked, do not move (or slide along edge for advanced logic)
// Example for CaitlynAI:
// let newX = this.x + ...; let newY = this.y + ...;
// if (!isBlockedMap(newX, newY)) { this.x = newX; this.y = newY; }
// else { /* Optionally: slide along edge or stop */ }
// ... existing code ...

// TEMPORARY DEBUG: Disable all map collision to test movement
function isBlockedMap(x, y) {
  return false; // <-- Disable collision for debugging
  // Original logic below:
  // for (const wall of MAP_WALLS) if (pointInPolygon(x, y, wall)) return true;
  // if (pointInPolygon(x, y, MAP_RIVER)) return true;
  // return false;
}

// Add this after constants and before CaitlynAI class
const ITEM_SHOP = [
  {
    name: 'Long Sword',
    cost: 500,
    ad: 12,
    icon: 'bf sword.webp', // fallback to text if image not available
    stackable: true
  }
];

</script>
</body>
</html>
